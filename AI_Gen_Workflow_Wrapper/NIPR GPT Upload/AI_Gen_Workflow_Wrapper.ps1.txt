
# AI_Gen_Workflow_Wrapper.ps1
# Core functionality and action handlers for the vCenter Migration Workflow Manager

# Note: This file is loaded by Launch.ps1 and should not be run directly

function Initialize-Application {
    Write-Log "Initializing application" -Level "INFO"
    
    # Initialize directory structure if needed
    if (-not (Test-Path -Path $script:config.ScriptsFolder)) {
        New-Item -Path $script:config.ScriptsFolder -ItemType Directory -Force | Out-Null
        Write-Log "Created scripts directory" -Level "INFO"
    }
    
    # Create reports directory if it doesn't exist
    if (-not (Test-Path -Path "$($PSScriptRoot)\reports")) {
        $script:config.ReportsPath = "$($PSScriptRoot)\reports"
        New-Item -Path $script:config.ReportsPath -ItemType Directory -Force | Out-Null
        Write-Log "Created reports directory" -Level "INFO"
    }
    
    # Initialize ListViews first
    Initialize-ListViews
    
    # Register event handlers
    Register-EventHandlers
    
    # Load saved settings
    Load-FormSettings
    
    # Check PowerCLI installation
    #Check-PowerCLI
    
    # Load scripts list
    Load-ScriptsList
    
    # Initialize scripts collection if it doesn't exist
    if ($null -eq $script:Scripts) {
        $script:Scripts = @()
        Write-Log "Initialized scripts collection" -Level "INFO"
    }
    
    # Set initial UI state
    Update-UIState -State "Ready"
    
    # Add diagnostics to help troubleshoot event handlers
    Diagnose-EventHandlers
    
    Write-Log "Application initialized successfully" -Level "INFO"
}

function Initialize-ListViews {
    # Initialize Scripts ListView columns
    $mainForm.lvScripts.Columns.Clear()
    $mainForm.lvScripts.Columns.Add("Order", 50) | Out-Null
    $mainForm.lvScripts.Columns.Add("Script", 200) | Out-Null
    $mainForm.lvScripts.Columns.Add("Enabled", 80) | Out-Null
    
    # Initialize Parameters ListView columns
    $mainForm.lvParameters.Columns.Clear()
    $mainForm.lvParameters.Columns.Add("Name", 120) | Out-Null
    $mainForm.lvParameters.Columns.Add("Value", 150) | Out-Null
    $mainForm.lvParameters.Columns.Add("Type", 100) | Out-Null
    
    Write-Log "ListView columns initialized"
}

function Register-EventHandlers {
    Write-Log "Registering event handlers" -Level "INFO"
    
    # Add Click handlers for Connection tab buttons
    $mainForm.btnTestSourceConnection.Add_Click({ Invoke-TestSourceConnection })
    $mainForm.btnTestTargetConnection.Add_Click({ Invoke-TestTargetConnection })
    
    $mainForm.chkUseCurrentCredentials.Add_CheckedChanged({
        $mainForm.txtSourceUsername.Enabled = -not $mainForm.chkUseCurrentCredentials.Checked
        $mainForm.txtSourcePassword.Enabled = -not $mainForm.chkUseCurrentCredentials.Checked
        $mainForm.txtTargetUsername.Enabled = -not $mainForm.chkUseCurrentCredentials.Checked
        $mainForm.txtTargetPassword.Enabled = -not $mainForm.chkUseCurrentCredentials.Checked
    })
    
    $mainForm.btnBrowse.Add_Click({ Browse-ScriptFile })
    $mainForm.btnSaveAll.Add_Click({ Save-AllSettings })
    $mainForm.btnExit.Add_Click({ $mainForm.Close() })
    $mainForm.btnHelp.Add_Click({ Show-Help })
    
    # Scripts tab event handlers
    $mainForm.lvScripts.Add_SelectedIndexChanged({ Load-ScriptDetails })
    
    Write-Log "Event handlers registered successfully" -Level "INFO"
}

function Diagnose-EventHandlers {
    Write-Log "Diagnosing event handlers for connection test buttons" -Level "INFO"
    
    # Check source connection button
    $sourceButton = $mainForm.btnTestSourceConnection
    Write-Log "Source Connection Button: $($sourceButton.Name)" -Level "DEBUG"
    
    # Check target connection button
    $targetButton = $mainForm.btnTestTargetConnection
    Write-Log "Target Connection Button: $($targetButton.Name)" -Level "DEBUG"
    
    # Try to get event handlers
    try {
        # This is a bit tricky in PowerShell since we can't easily enumerate all event handlers
        # But we can check if our handlers are registered correctly
        
        Write-Log "Verifying our handlers are registered" -Level "DEBUG"
        
        # Re-register the handlers to be sure
        $mainForm.btnTestSourceConnection.Add_Click({ 
            Write-Log "SOURCE CONNECTION BUTTON CLICKED - OUR HANDLER" -Level "DEBUG"
            Invoke-TestSourceConnection 
        })
        
        $mainForm.btnTestTargetConnection.Add_Click({ 
            Write-Log "TARGET CONNECTION BUTTON CLICKED - OUR HANDLER" -Level "DEBUG"
            Invoke-TestTargetConnection 
        })
        
        Write-Log "Event handlers re-registered" -Level "DEBUG"
    }
    catch {
        Write-Log "Error during event handler diagnosis: $($_)" -Level "ERROR"
    }
}

function Get-ParameterDisplayValue {
    param (
        [string]$value,
        [string]$type,
        [string]$name,
        [string]$sourceServer,
        [string]$targetServer,
        [string]$sourceUsername,
        [string]$targetUsername
    )

    if ($type -eq "String" -and ($name -like "*vCenter*" -or $name -like "*Server*")) {
        switch ($value) {
            "SourcevCenter" { return "$sourceServer (Source vCenter)" }
            "TargetvCenter" { return "$targetServer (Target vCenter)" }
            default { return $value }
        }
    }
    elseif ($type -eq "PSCredential") {
        switch ($value) {
            "SourceCredential" { return "$sourceUsername (Source Credentials)" }
            "TargetCredential" { return "$targetUsername (Target Credentials)" }
            default { return $value }
        }
    }
    return $value
}

# Then in your Detect-ScriptParameters function, modify the ListView addition:
# (Find where you add items to the ListView)

$item = New-Object System.Windows.Forms.ListViewItem($paramName)
if ($item -ne $null) {
    $displayValue = Get-ParameterDisplayValue `
        -value $defaultValue `
        -type $paramType `
        -name $paramName `
        -sourceServer $txtSourceServer.Text `
        -targetServer $txtTargetServer.Text `
        -sourceUsername $txtSourceUsername.Text `
        -targetUsername $txtTargetUsername.Text

    if ($defaultValue -ne $null) {
        $item.SubItems.Add($displayValue)
    }
    else {
        $item.SubItems.Add("")
    }

    if ($paramType -ne $null) {
        $item.SubItems.Add($paramType.ToString())
    }
    else {
        $item.SubItems.Add("String")
    }

    $lvParameters.Items.Add($item)
}
function Update-UIState {
    param (
        [Parameter(Mandatory = $true)]
        [ValidateSet("Ready", "Running", "Stopped", "Error")]
        [string]$State
    )
    
    switch ($State) {
        "Ready" {
            $btnRunAll.Enabled = $true
            $btnRunSelected.Enabled = $true
            $btnStopExecution.Enabled = $false
            $statusStripLabel.Text = "Ready"
        }
        "Running" {
            $btnRunAll.Enabled = $false
            $btnRunSelected.Enabled = $false
            $btnStopExecution.Enabled = $true
            $statusStripLabel.Text = "Running..."
        }
        "Stopped" {
            $btnRunAll.Enabled = $true
            $btnRunSelected.Enabled = $true
            $btnStopExecution.Enabled = $false
            $statusStripLabel.Text = "Execution stopped"
        }
        "Error" {
            $btnRunAll.Enabled = $true
            $btnRunSelected.Enabled = $true
            $btnStopExecution.Enabled = $false
            $statusStripLabel.Text = "Error occurred"
        }
    }
}

$btnExportLogs_Click = {
    try {
        # Implement log export logic
        $saveFileDialog = New-Object System.Windows.Forms.SaveFileDialog
        $saveFileDialog.Filter = "Text Files (*.txt)|*.txt|All Files (*.*)|*.*"
        $saveFileDialog.Title = "Export Logs"
        
        if ($saveFileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
            $logTextBox.Text | Out-File -FilePath $saveFileDialog.FileName -Encoding UTF8
            [System.Windows.Forms.MessageBox]::Show("Logs exported successfully!", "Export Successful", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error exporting logs: $_", "Export Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnClearLogs_Click = {
    try {
        $logTextBox.Clear()
        # Optionally, clear the actual log file
        # Add-LogMessage "Logs cleared manually"
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error clearing logs: $_", "Clear Logs Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnRefreshLogs_Click = {
        try {
        # Implement log refresh logic
        # This might involve reading the latest log file or reloading logs
        if (Test-Path $Global:LogFilePath) {
            $logTextBox.Text = Get-Content $Global:LogFilePath -Raw
        }
        else {
            $logTextBox.Text = "No log file found."
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error refreshing logs: $_", "Refresh Logs Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnStopExecution_Click = {
    try {
        # Implement script execution stop logic
        if ($Global:ExecutionJob) {
            Stop-Job $Global:ExecutionJob
            Remove-Job $Global:ExecutionJob
            $btnStopExecution.Enabled = $false
            $statusStripLabel.Text = "Execution stopped by user"
            # Add additional cleanup or reset logic
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error stopping execution: $_", "Stop Execution Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnRunSelected_Click = {
    try {
        # Implement run selected script logic
        if ($lvScripts.SelectedItems.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("Please select a script to run.", "No Script Selected", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }

        $selectedScript = $lvScripts.SelectedItems[0]
        # Add logic to run the selected script
        # This might involve creating a background job, updating progress, etc.
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error running selected script: $_", "Script Execution Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnRunAll_Click = {
    try {
        # Validate scripts exist and are enabled
        if ($lvScripts.Items.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("No scripts available to run.", "Run All Scripts", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
            return
        }

        # Confirm execution
        $confirmResult = [System.Windows.Forms.MessageBox]::Show("Are you sure you want to run all scripts?", "Confirm Execution", [System.Windows.Forms.MessageBoxButtons]::YesNo, [System.Windows.Forms.MessageBoxIcon]::Question)
        if ($confirmResult -eq [System.Windows.Forms.DialogResult]::No) {
            return
        }

        # Prepare for script execution
        $progressOverall.Value = 0
        $progressOverall.Maximum = ($lvScripts.Items | Where-Object { $_.SubItems[2].Text -eq 'True' }).Count
        $txtExecutionOutput.Clear()

        # Start background job to run scripts
        $Global:ExecutionJob = Start-Job -ScriptBlock {
            param($scripts, $stopOnError)
            
            $results = @()
            foreach ($script in $scripts) {
                try {
                    $result = Invoke-Expression $script.Path
                    $results += @{
                        ScriptPath = $script.Path
                        Success = $true
                        Output = $result
                    }
                }
                catch {
                    $results += @{
                        ScriptPath = $script.Path
                        Success = $false
                        Error = $_.Exception.Message
                    }
                    
                    if ($stopOnError) {
                        break
                    }
                }
            }
            return $results
        } -ArgumentList @(
            ($lvScripts.Items | Where-Object { $_.SubItems[2].Text -eq 'True' } | ForEach-Object { 
                @{ Path = $_.SubItems[1].Text }
            }),
            $chkStopOnError.Checked
        )

        # Monitor job progress
        $timer = New-Object System.Windows.Forms.Timer
        $timer.Interval = 1000
        $timer.Add_Tick({
            if ($Global:ExecutionJob.State -ne 'Running') {
                $timer.Stop()
                $results = Receive-Job $Global:ExecutionJob

                # Update UI with results
                $results | ForEach-Object {
                    if ($_.Success) {
                        $txtExecutionOutput.AppendText("Script: $($_.ScriptPath)`nSuccess`n")
                    }
                    else {
                        $txtExecutionOutput.AppendText("Script: $($_.ScriptPath)`nError: $($_.Error)`n")
                    }
                }

                $progressOverall.Value = $progressOverall.Maximum
                $statusStripLabel.Text = "Execution completed"
                $btnStopExecution.Enabled = $false
            }
            else {
                $progressOverall.Value++
            }
        })
        $timer.Start()

        $btnStopExecution.Enabled = $true
        $statusStripLabel.Text = "Running all scripts..."
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error running scripts: $_", "Execution Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnSaveScriptDetails_Click = {
    try {
        # Validate required fields
        if ([string]::IsNullOrWhiteSpace($txtScriptPath.Text)) {
            [System.Windows.Forms.MessageBox]::Show("Please select a script file.", "Validation Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }

        # If a script is selected in the list, update its details
        if ($lvScripts.SelectedIndices.Count -gt 0) {
            $selectedIndex = $lvScripts.SelectedIndices[0]
            $lvScripts.Items[$selectedIndex].SubItems[1].Text = $txtScriptPath.Text
            $lvScripts.Items[$selectedIndex].SubItems[2].Text = $chkScriptEnabled.Checked.ToString()
        }
        else {
            # Add new script to the list
            $newItem = $lvScripts.Items.Add((($lvScripts.Items.Count + 1).ToString()))
            $newItem.SubItems.Add($txtScriptPath.Text)
            $newItem.SubItems.Add($chkScriptEnabled.Checked.ToString())
        }

        # Clear input fields
        $txtScriptPath.Clear()
        $txtScriptDescription.Clear()
        $chkScriptEnabled.Checked = $false
        $lvParameters.Items.Clear()

        [System.Windows.Forms.MessageBox]::Show("Script details saved successfully.", "Save Successful", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error saving script details: $_", "Save Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnDetectParams_Click = {
    try {
        # Get the selected script
        $selectedIndex = $lvScripts.SelectedIndices[0]
        if ($selectedIndex -eq $null) {
            [System.Windows.Forms.MessageBox]::Show("Please select a script first.", "No Script Selected", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }

        $scriptPath = $script:Scripts[$selectedIndex].Path
        if (-not (Test-Path $scriptPath)) {
            [System.Windows.Forms.MessageBox]::Show("Script file not found: $scriptPath", "File Not Found", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
            return
        }

        try {
            # Clear existing parameters
            $lvParameters.Items.Clear()

            # Read the script content
            $scriptContent = Get-Content -Path $scriptPath -Raw -ErrorAction Stop

            Write-Log "Detecting parameters for script: $scriptPath"

            # Parse the script using AST
            $ast = [System.Management.Automation.Language.Parser]::ParseInput($scriptContent, [ref]$null, [ref]$null)

            # Find the param block
            $paramBlock = $ast.ParamBlock
            if ($null -eq $paramBlock -or $null -eq $paramBlock.Parameters -or $paramBlock.Parameters.Count -eq 0) {
                Write-Log "No parameters found in script: $scriptPath"
                [System.Windows.Forms.MessageBox]::Show("No parameters found in the script.", "No Parameters", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
                return
            }

            # Extract comment-based help for parameter descriptions
            $helpContent = $null
            if ($ast.GetHelpContent()) {
                $helpContent = $ast.GetHelpContent()
            }

            # Process each parameter
            $detectedParams = @()

            foreach ($param in $paramBlock.Parameters) {
                $paramName = $param.Name.VariablePath.UserPath
                Write-Log "Found parameter: $paramName"

                # Get parameter type
                $paramType = "String"  # Default type
                if ($param.StaticType) {
                    $paramType = $param.StaticType.Name
                }

                # Get default value if any
                $defaultValue = ""
                if ($param.DefaultValue) {
                    $defaultValue = $param.DefaultValue.Extent.Text
                }

                # Get description from help content if available
                $description = ""
                if ($helpContent -and $helpContent.Parameters -and $helpContent.Parameters.ContainsKey($paramName)) {
                    $description = $helpContent.Parameters[$paramName]
                }

                # Set default values for common parameters
                if ($paramName -eq "vCenterConnection") {
                    $defaultValue = "SourceConnection"
                }
                elseif ($paramName -eq "LogOutputLocation") {
                    $defaultValue = $script:config.LogPath
                }
                elseif ($paramName -eq "ReportOutputLocation") {
                    $defaultValue = $script:config.ReportsPath
                }

                # Create parameter object
                $paramObject = [PSCustomObject]@{
                    Name        = $paramName
                    Value       = $defaultValue
                    Type        = $paramType
                    Description = $description
                }

                $detectedParams += $paramObject

                # Add to ListView - with null checks
                $item = New-Object System.Windows.Forms.ListViewItem($paramName)
                if ($item -ne $null) {
                    if ($defaultValue -ne $null) {
                        $item.SubItems.Add($defaultValue.ToString())
                    }
                    else {
                        $item.SubItems.Add("")
                    }

                    if ($paramType -ne $null) {
                        $item.SubItems.Add($paramType.ToString())
                    }
                    else {
                        $item.SubItems.Add("String")
                    }

                    $lvParameters.Items.Add($item)
                }
                else {
                    Write-Log "Error: Failed to create ListView item for parameter $paramName" -Level "ERROR"
                }
            }

            # Update the script's parameters
            $script:Scripts[$selectedIndex].Parameters = $detectedParams

            Write-Log "Detected $($detectedParams.Count) parameters for script: $scriptPath"
            [System.Windows.Forms.MessageBox]::Show("Detected $($detectedParams.Count) parameters.", "Parameters Detected", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        }
        catch {
            $errorMessage = "Error detecting script parameters: $($_.Exception.Message)"
            Write-Log $errorMessage -Level "ERROR"
            Write-Log "Stack Trace: $($_.ScriptStackTrace)" -Level "ERROR"
            [System.Windows.Forms.MessageBox]::Show($errorMessage, "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        }
    }
    catch {
        Write-Log "Error in '$btnDetectParams_Click': $($_.Exception.Message)" -Level "ERROR"
        [System.Windows.Forms.MessageBox]::Show("Error in '$btnDetectParams_Click': $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnRemoveParam_Click = {
    try {
        if ($lvParameters.SelectedIndices.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("Please select a parameter to remove.", "Remove Parameter", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }

        $lvParameters.Items.RemoveAt($lvParameters.SelectedIndices[0])
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error removing parameter: $_", "Remove Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnEditParam_Click = {
    try {
        Write-Log "btnEditParam_Click: Starting" -Level "DEBUG"

        # Verify config
        if (-not $script:config) {
            Write-Log "Config is null" -Level "ERROR"
            return
        }
        
        if (-not $script:config.FormPath) {
            Write-Log "FormPath is missing from config" -Level "ERROR"
            $script:config.FormPath = $PSScriptRoot
            Write-Log "Set FormPath to: $($script:config.FormPath)" -Level "DEBUG"
        }

        # Get selected parameter first
        if ($lvParameters.SelectedItems.Count -eq 0) {
            Write-Log "btnEditParam_Click: No parameter selected" -Level "WARNING"
            [System.Windows.Forms.MessageBox]::Show(
                "Please select a parameter to edit.", 
                "No Parameter Selected", 
                [System.Windows.Forms.MessageBoxButtons]::OK, 
                [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }

        # Get script index and verify
        $scriptIndex = $lvScripts.SelectedIndices[0]
        if ($scriptIndex -lt 0 -or $scriptIndex -ge $script:Scripts.Count) {
            Write-Log "btnEditParam_Click: Invalid script index" -Level "ERROR"
            return
        }

        # Get selected script
        $selectedScript = $script:Scripts[$scriptIndex]
        if ($null -eq $selectedScript) {
            Write-Log "btnEditParam_Click: selectedScript is NULL" -Level "ERROR"
            return
        }

        # Get parameter index and parameter
        $selectedItem = $lvParameters.SelectedItems[0]
        $paramIndex = $lvParameters.Items.IndexOf($selectedItem)
        $currentParam = $selectedScript.Parameters[$paramIndex]

        Write-Log "btnEditParam_Click: currentParam type is: $($currentParam.GetType().FullName)" -Level "DEBUG"
        Write-Log "btnEditParam_Click: currentParam = $($currentParam | ConvertTo-Json)" -Level "DEBUG"

        # Get connection info
        $connectionInfo = @{
            SourceServer = $txtSourceServer.Text
            TargetServer = $txtTargetServer.Text
        }

        Write-Log "btnEditParam_Click: connectionInfo = $($connectionInfo | ConvertTo-Json)" -Level "DEBUG"

        # Get script path
        $scriptPath = $selectedScript.Path
        Write-Log "btnEditParam_Click: scriptPath = $($scriptPath)" -Level "DEBUG"

        if ([string]::IsNullOrEmpty($scriptPath)) {
            Write-Log "btnEditParam_Click: scriptPath is EMPTY!" -Level "ERROR"
            return
        }

        # Show the edit form
        $updatedParam = Show-EditParameterForm `
            -Parameter $currentParam `
            -ConnectionInfo $connectionInfo `
            -ScriptPath $scriptPath `
            -Config $script:config

        # Update if we got a result
        if ($updatedParam) {
            Write-Log "Received updated parameter: $($updatedParam | ConvertTo-Json)" -Level "DEBUG"

            # Get the display value based on the parameter type and value
            $displayValue = $updatedParam.Value
            if ($updatedParam.Type -eq "String" -and 
                ($updatedParam.Name -like "*vCenter*" -or $updatedParam.Name -like "*Server*")) {
                switch ($updatedParam.Value) {
                    "SourcevCenter" { 
                        $displayValue = "$($txtSourceServer.Text) (Source vCenter)"
                    }
                    "TargetvCenter" { 
                        $displayValue = "$($txtTargetServer.Text) (Target vCenter)"
                    }
                    default { $displayValue = $updatedParam.Value }
                }
            }
            elseif ($updatedParam.Type -eq "PSCredential") {
                switch ($updatedParam.Value) {
                    "SourceCredential" { 
                        $displayValue = "$($txtSourceUsername.Text) (Source Credentials)"
                    }
                    "TargetCredential" { 
                        $displayValue = "$($txtTargetUsername.Text) (Target Credentials)"
                    }
                    default { $displayValue = $updatedParam.Value }
                }
            }

            Write-Log "Using display value: $displayValue" -Level "DEBUG"

            # Update the parameter in the list view with the display value
            $selectedItem.SubItems[1].Text = $displayValue
            $selectedItem.SubItems[2].Text = $updatedParam.Type

            # Find and update the matching parameter in the script's parameters
            # (Keep the original value, not the display value)
            $script:Scripts[$scriptIndex].Parameters | 
                Where-Object { $_.Name -eq $currentParam.Name } | 
                ForEach-Object {
                    $_.Value = $updatedParam.Value  # Keep original value
                    $_.Type = $updatedParam.Type
                    Write-Log "Updated parameter in script: Name=$($_.Name), Value=$($_.Value), Type=$($_.Type)" -Level "DEBUG"
                }
        }
        else {
            Write-Log "Parameter update cancelled or failed" -Level "DEBUG"
        }

        Write-Log "btnEditParam_Click: Ending" -Level "DEBUG"
    }
    catch {
        Write-Log "Error in btnEditParam_Click: $($_.Exception.Message)" -Level "ERROR"
        Write-Log "Stack trace: $($_.ScriptStackTrace)" -Level "ERROR"
        [System.Windows.Forms.MessageBox]::Show(
            "Error in btnEditParam_Click: $($_.Exception.Message)", 
            "Error", 
            [System.Windows.Forms.MessageBoxButtons]::OK, 
            [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}


$btnAddParam_Click = {
    try {
        # Create a dialog for adding a new parameter
        $inputForm = New-Object System.Windows.Forms.Form
        $inputForm.Text = "Add Parameter"
        $inputForm.Size = New-Object System.Drawing.Size(300,250)
        $inputForm.StartPosition = "CenterScreen"

        $labelName = New-Object System.Windows.Forms.Label
        $labelName.Text = "Parameter Name:"
        $labelName.Location = New-Object System.Drawing.Point(10,20)
        $labelName.Size = New-Object System.Drawing.Size(100,20)
        $inputForm.Controls.Add($labelName)

        $textName = New-Object System.Windows.Forms.TextBox
        $textName.Location = New-Object System.Drawing.Point(120,20)
        $textName.Size = New-Object System.Drawing.Size(150,20)
        $inputForm.Controls.Add($textName)

        $labelType = New-Object System.Windows.Forms.Label
        $labelType.Text = "Parameter Type:"
        $labelType.Location = New-Object System.Drawing.Point(10,50)
        $labelType.Size = New-Object System.Drawing.Size(100,20)
        $inputForm.Controls.Add($labelType)

        $comboType = New-Object System.Windows.Forms.ComboBox
        $comboType.Location = New-Object System.Drawing.Point(120,50)
        $comboType.Size = New-Object System.Drawing.Size(150,20)
        $comboType.Items.AddRange(@("String", "Int32", "Boolean", "PSCredential", "Array"))
        $inputForm.Controls.Add($comboType)

        $labelValue = New-Object System.Windows.Forms.Label
        $labelValue.Text = "Parameter Value:"
        $labelValue.Location = New-Object System.Drawing.Point(10,80)
        $labelValue.Size = New-Object System.Drawing.Size(100,20)
        $inputForm.Controls.Add($labelValue)

        $textValue = New-Object System.Windows.Forms.TextBox
        $textValue.Location = New-Object System.Drawing.Point(120,80)
        $textValue.Size = New-Object System.Drawing.Size(150,20)
        $inputForm.Controls.Add($textValue)

        $btnOK = New-Object System.Windows.Forms.Button
        $btnOK.Text = "Add"
        $btnOK.DialogResult = [System.Windows.Forms.DialogResult]::OK
        $btnOK.Location = New-Object System.Drawing.Point(100,150)
        $inputForm.Controls.Add($btnOK)
        $inputForm.AcceptButton = $btnOK

        $result = $inputForm.ShowDialog()
        if ($result -eq [System.Windows.Forms.DialogResult]::OK) {
            if ([string]::IsNullOrWhiteSpace($textName.Text) -or [string]::IsNullOrWhiteSpace($comboType.SelectedItem)) {
                [System.Windows.Forms.MessageBox]::Show("Please enter a parameter name and select a type.", "Validation Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
                return
            }

            $newItem = $lvParameters.Items.Add($textName.Text)
            $newItem.SubItems.Add($textValue.Text)
            $newItem.SubItems.Add($comboType.SelectedItem)
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error adding parameter: $_", "Add Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnMoveDown_Click = {
    try {
        if ($lvScripts.SelectedIndices.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("Please select a script to move.", "Move Script", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }

        $selectedIndex = $lvScripts.SelectedIndices[0]
        if ($selectedIndex -lt $lvScripts.Items.Count - 1) {
            $currentItem = $lvScripts.Items[$selectedIndex]
            $nextItem = $lvScripts.Items[$selectedIndex + 1]

            # Swap order numbers
            $tempOrder = $currentItem.SubItems[0].Text
            $currentItem.SubItems[0].Text = $nextItem.SubItems[0].Text
            $nextItem.SubItems[0].Text = $tempOrder

            # Remove and re-insert to change position
            $lvScripts.Items.Remove($currentItem)
            $lvScripts.Items.Insert($selectedIndex + 1, $currentItem)
            $lvScripts.Items[$selectedIndex + 1].Selected = $true
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error moving script down: $_", "Move Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnMoveUp_Click = {
    try {
        if ($lvScripts.SelectedIndices.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("Please select a script to move.", "Move Script", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }

        $selectedIndex = $lvScripts.SelectedIndices[0]
        if ($selectedIndex -gt 0) {
            $currentItem = $lvScripts.Items[$selectedIndex]
            $prevItem = $lvScripts.Items[$selectedIndex - 1]

            # Swap order numbers
            $tempOrder = $currentItem.SubItems[0].Text
            $currentItem.SubItems[0].Text = $prevItem.SubItems[0].Text
            $prevItem.SubItems[0].Text = $tempOrder

            # Remove and re-insert to change position
            $lvScripts.Items.Remove($currentItem)
            $lvScripts.Items.Insert($selectedIndex - 1, $currentItem)
            $lvScripts.Items[$selectedIndex - 1].Selected = $true
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error moving script up: $_", "Move Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnRemoveScript_Click = {
    try {
        if ($lvScripts.SelectedIndices.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("Please select a script to remove.", "Remove Script", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }

        $confirmResult = [System.Windows.Forms.MessageBox]::Show("Are you sure you want to remove the selected script?", "Confirm Removal", [System.Windows.Forms.MessageBoxButtons]::YesNo, [System.Windows.Forms.MessageBoxIcon]::Question)
        if ($confirmResult -eq [System.Windows.Forms.DialogResult]::Yes) {
            $lvScripts.Items.RemoveAt($lvScripts.SelectedIndices[0])

            # Reorder remaining scripts
            for ($i = 0; $i -lt $lvScripts.Items.Count; $i++) {
                $lvScripts.Items[$i].SubItems[0].Text = ($i + 1).ToString()
            }
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error removing script: $_", "Remove Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnAddScript_Click = {
    try {
        Write-Log "btnAddScript_Click: Starting" -Level "DEBUG"
        $openFileDialog = New-Object System.Windows.Forms.OpenFileDialog
        $openFileDialog.Filter = "PowerShell Scripts (*.ps1)|*.ps1|All Files (*.*)|*.*"
        $openFileDialog.Title = "Select PowerShell Script"

        Write-Log "btnAddScript_Click: Showing OpenFileDialog" -Level "DEBUG"
        if ($openFileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
            Write-Log "btnAddScript_Click: OpenFileDialog returned OK" -Level "DEBUG"
            $scriptPath = $openFileDialog.FileName

             # Get the next order number
            $nextOrder = 1
            if ($script:Scripts.Count -gt 0) {
                $nextOrder = ($script:Scripts | Measure-Object -Property Order -Maximum).Maximum + 1
            }
            Write-Log "Next order number: $nextOrder"

            # Get script name from path
            $scriptName = [System.IO.Path]::GetFileName($scriptPath)
            Write-Log "Script name: $scriptName"

            # Add to scripts collection first
            Write-Log "Adding script to collection"
            $script:Scripts += @{
                Order = $nextOrder
                Name = $scriptName
                Path = $scriptPath
                Description = "" #Description not used in this function
                Enabled = $true #Enabled is true by default
                Parameters = @()
            }

            # Add script to ListView
            Write-Log "btnAddScript_Click: Adding script to ListView" -Level "DEBUG"
            $newItem = $lvScripts.Items.Add($nextOrder.ToString())
            $newItem.SubItems.Add($scriptName) # Changed to scriptName
            $newItem.SubItems.Add("True") # Default enabled


            # Select the new item
            #$newItem.Selected = $true  # **REMOVE THIS LINE - causes the double call**

            # Populate script details
            Write-Log "btnAddScript_Click: Populating script details" -Level "DEBUG"
            $txtScriptPath.Text = $scriptPath
            $txtScriptDescription.Text = "" #Description not used in this function
            $chkScriptEnabled.Checked = $true

             #Load Details Manually
            Load-ScriptDetails

            Write-Log "btnAddScript_Click: Ending" -Level "DEBUG"
        }
        else {
            Write-Log "btnAddScript_Click: OpenFileDialog returned Cancel" -Level "DEBUG"
        }
        
    }
    catch {
        Write-Log "Error in '\$btnAddScript_Click': $($_.Exception.Message)" -Level "ERROR"
        [System.Windows.Forms.MessageBox]::Show("Error adding script: $_", "Add Script Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}


$btnLoadConnection_Click = {
    try {
        $openFileDialog = New-Object System.Windows.Forms.OpenFileDialog
        $openFileDialog.Filter = "JSON Files (*.json)|*.json|All Files (*.*)|*.*"
        $openFileDialog.Title = "Load Connection Settings"

        if ($openFileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
            $connectionSettings = Get-Content $openFileDialog.FileName | ConvertFrom-Json

            $txtSourceServer.Text = $connectionSettings.SourceServer
            $txtSourceUsername.Text = $connectionSettings.SourceUsername
            $txtTargetServer.Text = $connectionSettings.TargetServer
            $txtTargetUsername.Text = $connectionSettings.TargetUsername

            $chkUseCurrentCredentials.Checked = $connectionSettings.UseCurrentCredentials

            [System.Windows.Forms.MessageBox]::Show("Connection settings loaded successfully.", "Load Successful", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error loading connection settings: $_", "Load Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

$btnSaveConnection_Click = {
    try {
        $saveFileDialog = New-Object System.Windows.Forms.SaveFileDialog
        $saveFileDialog.Filter = "JSON Files (*.json)|*.json|All Files (*.*)|*.*"
        $saveFileDialog.Title = "Save Connection Settings"

        if ($saveFileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
            $connectionSettings = @{
                SourceServer = $txtSourceServer.Text
                SourceUsername = $txtSourceUsername.Text
                TargetServer = $txtTargetServer.Text
                TargetUsername = $txtTargetUsername.Text
                UseCurrentCredentials = $chkUseCurrentCredentials.Checked
            }

            $connectionSettings | ConvertTo-Json | Out-File $saveFileDialog.FileName

            [System.Windows.Forms.MessageBox]::Show("Connection settings saved successfully.", "Save Successful", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Error saving connection settings: $_", "Save Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}



# Handler for Source vCenter connection test button
function Invoke-TestSourceConnection {
    Write-Log "SOURCE CONNECTION BUTTON HANDLER INVOKED" -Level "DEBUG"
    Test-vCenterConnection -ServerType "Source"
}

function Invoke-TestTargetConnection {
    Write-Log "TARGET CONNECTION BUTTON HANDLER INVOKED" -Level "DEBUG"
    Test-vCenterConnection -ServerType "Target"
}

function Test-vCenterConnection {
    param(
        [Parameter(Mandatory=$true)]
        [string]$ServerType # "Source" or "Target"
    )
    try {
        Write-Log "==== STARTING CONNECTION TEST FOR $($ServerType) VCENTER ====" -Level "INFO"
        
        # Get connection information based on server type
        if ($ServerType -eq "Source") {
            $server = $mainForm.txtSourceServer.Text
            $username = $mainForm.txtSourceUsername.Text
            $password = $mainForm.txtSourcePassword.Text
            $groupBox = $mainForm.grpSource
            Write-Log "Using Source vCenter parameters: Server=$($server), Username=$($username), Password=*****" -Level "DEBUG"
        } else {
            $server = $mainForm.txtTargetServer.Text
            $username = $mainForm.txtTargetUsername.Text
            $password = $mainForm.txtTargetPassword.Text
            $groupBox = $mainForm.grpTarget
            Write-Log "Using Target vCenter parameters: Server=$($server), Username=$($username), Password=*****" -Level "DEBUG"
        }
        
        # Clear any existing status label
        $existingLabel = $groupBox.Controls | Where-Object { $_.Name -eq "lblConnectionStatus" }
        if ($existingLabel) {
            $groupBox.Controls.Remove($existingLabel)
        }
        
        $useCurrentCreds = $mainForm.chkUseCurrentCredentials.Checked
        Write-Log "UseCurrentCredentials setting: $($useCurrentCreds)" -Level "DEBUG"
        
        # Validate connection info
        if ([string]::IsNullOrWhiteSpace($server)) {
            Write-Log "ERROR: Server address is empty" -Level "ERROR"
            [System.Windows.Forms.MessageBox]::Show(
                "Please enter a $($ServerType) server address.", 
                "Validation Error", 
                [System.Windows.Forms.MessageBoxButtons]::OK, 
                [System.Windows.Forms.MessageBoxIcon]::Warning
            )
            return $false
        }
        
        # If using current credentials, make sure we don't have empty username/password
        # that would trigger a credential prompt
        if ($useCurrentCreds) {
            Write-Log "Using Windows current credentials for authentication" -Level "INFO"
            # Make sure this is clear to prevent accidental credential prompt
            $username = ""
            $password = ""
            Write-Log "Cleared username/password since current credentials will be used" -Level "DEBUG"
        } else {
            Write-Log "Using explicit credentials for authentication" -Level "INFO"
            # Validate username and password are provided
            if ([string]::IsNullOrWhiteSpace($username)) {
                Write-Log "ERROR: Username is empty" -Level "ERROR"
                [System.Windows.Forms.MessageBox]::Show(
                    "Please enter a username for $($ServerType) vCenter.",
                    "Validation Error",
                    [System.Windows.Forms.MessageBoxButtons]::OK,
                    [System.Windows.Forms.MessageBoxIcon]::Warning
                )
                return $false
            }
            
            if ([string]::IsNullOrWhiteSpace($password)) {
                Write-Log "ERROR: Password is empty" -Level "ERROR"
                [System.Windows.Forms.MessageBox]::Show(
                    "Please enter a password for $($ServerType) vCenter.",
                    "Validation Error",
                    [System.Windows.Forms.MessageBoxButtons]::OK,
                    [System.Windows.Forms.MessageBoxIcon]::Warning
                )
                return $false
            }
            
            Write-Log "Username and password validation passed" -Level "DEBUG"
        }
        
        # Check if PowerCLI is available (only if we haven't determined it exists yet)
        if (-not $script:PowerCLIExistsChecked) {
            $script:PowerCLIExists = (Get-Module -Name VMware.PowerCLI -ListAvailable) -or 
                                      (Get-Module -Name VMware.VimAutomation.Core -ListAvailable)
            $script:PowerCLIExistsChecked = $true # Set the flag
            Write-Log "PowerCLI module exists: $($script:PowerCLIExists)" -Level "DEBUG"
        } else {
            Write-Log "Skipping PowerCLI module existence check (already checked)" -Level "DEBUG"
        }
        
        if (-not $script:PowerCLIExists) {
            Write-Log "VMware PowerCLI module is not installed." -Level "WARNING"
            $message = "VMware PowerCLI module is not installed. This tool requires PowerCLI for vCenter operations.`n`n"
            $message += "Please install PowerCLI using:`nInstall-Module -Name VMware.PowerCLI -Scope CurrentUser -Force"
            
            [System.Windows.Forms.MessageBox]::Show(
                $message, 
                "PowerCLI Not Found", 
                [System.Windows.Forms.MessageBoxButtons]::OK, 
                [System.Windows.Forms.MessageBoxIcon]::Warning
            )
            return $false
        }
        
        # Check if PowerCLI module is already loaded
        if (-not $script:PowerCLIImported) {
            # Import PowerCLI module if needed
            $powerCLILoaded = (Get-Module -Name VMware.PowerCLI) -or 
                              (Get-Module -Name VMware.VimAutomation.Core)
            
            Write-Log "PowerCLI module loaded: $($powerCLILoaded)" -Level "DEBUG"
            
            if (-not $powerCLILoaded) {
                Write-Log "Importing VMware PowerCLI module" -Level "INFO"
                try {
                    if (Get-Module -Name VMware.PowerCLI -ListAvailable) {
                        Write-Log "Importing VMware.PowerCLI" -Level "DEBUG"
                        Import-Module -Name VMware.PowerCLI -ErrorAction Stop
                    } else {
                        Write-Log "Importing VMware.VimAutomation.Core" -Level "DEBUG"
                        Import-Module -Name VMware.VimAutomation.Core -ErrorAction Stop
                    }
                    Write-Log "Successfully imported PowerCLI module" -Level "INFO"
                    $script:PowerCLIImported = $true  # Set the flag
                }
                catch {
                    Write-Log "Failed to import PowerCLI module: $($_)" -Level "ERROR"
                    [System.Windows.Forms.MessageBox]::Show(
                        "Failed to import PowerCLI module: $($_)", 
                        "Module Error", 
                        [System.Windows.Forms.MessageBoxButtons]::OK, 
                        [System.Windows.Forms.MessageBoxIcon]::Error
                    )
                    return $false
                }
            }
        } else {
            Write-Log "PowerCLI module already imported, skipping Import-Module" -Level "DEBUG"
        }
        
        # Set PowerCLI configuration to ignore invalid certificates
        Write-Log "Setting PowerCLI configuration to ignore invalid certificates" -Level "DEBUG"
        Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -ErrorAction SilentlyContinue | Out-Null
        
        # Attempt to connect with status updates
        $mainForm.statusStripLabel.Text = "Connecting to $($ServerType) vCenter..."
        Write-Log "Connecting to $($ServerType) vCenter: $($server)" -Level "INFO"
        
            try {
            Write-Log "===== CONNECTION ATTEMPT STARTING =====" -Level "DEBUG"
            $connectionParams = @{
                Server = $server
                ErrorAction = "Stop"
            }

            if ($useCurrentCreds) {
                Write-Log ">>> CONNECTING WITH WINDOWS AUTHENTICATION" -Level "DEBUG"
                Write-Log "Using Connect-VIServer with -Force flag and NO credential parameter" -Level "DEBUG"
                $connectionParams["Force"] = $true  # Add the -Force parameter
            } else {
                Write-Log ">>> CREATING CREDENTIAL OBJECT" -Level "DEBUG"
                # Create credential from username/password
                Write-Log "Converting password to secure string" -Level "DEBUG"
                $securePassword = ConvertTo-SecureString -String $password -AsPlainText -Force

                Write-Log "Creating PSCredential object for user: $($username)" -Level "DEBUG"
                $credential = New-Object System.Management.Automation.PSCredential($username, $securePassword)

                Write-Log ">>> CONNECTING WITH EXPLICIT CREDENTIALS" -Level "DEBUG"
                Write-Log "Using Connect-VIServer with -Credential parameter, username=$($username)" -Level "DEBUG"
                $connectionParams["Credential"] = $credential  # Add the -Credential parameter
            }

            # Connect to vCenter using splatting
            Write-Log "Connecting to vCenter server using parameters: $($connectionParams)" -Level "DEBUG"
            $connection = Connect-VIServer @connectionParams
            Write-Log "Connection attempt completed" -Level "DEBUG"
            
            Write-Log "Connection attempt completed" -Level "DEBUG"
            
            if ($connection) {
                    Write-Log "Connection successful. Connection type: $($connection.GetType().FullName)" -Level "DEBUG"
                    Write-Log "$($ServerType) vCenter connection successful" -Level "INFO"
                    $mainForm.statusStripLabel.Text = "$($ServerType) vCenter connection successful"
                    
                    # Add a green connection status label to the group box
                    $statusLabel = New-Object System.Windows.Forms.Label
                    $statusLabel.Name = "lblConnectionStatus"
                    $statusLabel.Text = "âœ“ Connected to $($server)"
                    $statusLabel.ForeColor = [System.Drawing.Color]::Green
                    $statusLabel.Font = New-Object System.Drawing.Font($statusLabel.Font, [System.Drawing.FontStyle]::Bold)
                    $statusLabel.AutoSize = $true
                    $statusLabel.Location = New-Object System.Drawing.Point(10, 120)
                    $statusLabel.Size = New-Object System.Drawing.Size(330, 20)
                    $groupBox.Controls.Add($statusLabel)
                    
                    [System.Windows.Forms.MessageBox]::Show(
                        "Successfully connected to $($ServerType) vCenter server!",
                        "Connection Test", 
                        [System.Windows.Forms.MessageBoxButtons]::OK, 
                        [System.Windows.Forms.MessageBoxIcon]::Information
                    )
                    
                    return $true
                }
            else{}
        }
        catch {
            $errorMessage = $_.Exception.Message
            Write-Log "Exception during connection: $($errorMessage)" -Level "ERROR" 
            Write-Log "Exception type: $($_.Exception.GetType().FullName)" -Level "ERROR"
            Write-Log "Stack trace: $($_.ScriptStackTrace)" -Level "ERROR"
            
            $mainForm.statusStripLabel.Text = "$($ServerType) vCenter connection failed"
            
            # Add a red error status label to the group box
            $statusLabel = New-Object System.Windows.Forms.Label
            $statusLabel.Name = "lblConnectionStatus"
            $statusLabel.Text = "âœ— Connection Failed"
            $statusLabel.ForeColor = [System.Drawing.Color]::Red
            $statusLabel.Font = New-Object System.Drawing.Font($statusLabel.Font, [System.Drawing.FontStyle]::Bold)
            $statusLabel.AutoSize = $true
            $statusLabel.Location = New-Object System.Drawing.Point(10, 120)
            $statusLabel.Size = New-Object System.Drawing.Size(330, 20)
            $groupBox.Controls.Add($statusLabel)
            
            [System.Windows.Forms.MessageBox]::Show(
                "Connection Failed:`n$($errorMessage)", 
                "Connection Error", 
                [System.Windows.Forms.MessageBoxButtons]::OK, 
                [System.Windows.Forms.MessageBoxIcon]::Error
            )
            return $false
        }
    }
    catch {
        $errorMessage = $_.Exception.Message
        Write-Log "Unexpected error in Test-vCenterConnection: $($errorMessage)" -Level "ERROR"
        Write-Log "Error type: $($_.Exception.GetType().FullName)" -Level "ERROR"
        Write-Log "Stack trace: $($_.ScriptStackTrace)" -Level "ERROR"
        
        $mainForm.statusStripLabel.Text = "Connection test error"
        
        [System.Windows.Forms.MessageBox]::Show(
            "Connection Test Error:`n$($errorMessage)", 
            "Connection Error", 
            [System.Windows.Forms.MessageBoxButtons]::OK, 
            [System.Windows.Forms.MessageBoxIcon]::Error
        )
        return $false
    }
    finally {
        Write-Log "==== CONNECTION TEST COMPLETED FOR $($ServerType) VCENTER ====" -Level "INFO"
    }
}


function Save-ConnectionSettings {
    $script:vCenterConfig.SourcevCenter = $txtSourceServer.Text
    $script:vCenterConfig.SourceUsername = $txtSourceUsername.Text
    $script:vCenterConfig.SourcePassword = $txtSourcePassword.Text
    $script:vCenterConfig.TargetvCenter = $txtTargetServer.Text
    $script:vCenterConfig.TargetUsername = $txtTargetUsername.Text
    $script:vCenterConfig.TargetPassword = $txtTargetPassword.Text
    $script:vCenterConfig.UseCurrentCredentials = $chkUseCurrentCredentials.Checked
    
    $saved = Save-MigrationConfig
    if ($saved) {
        $statusStripLabel.Text = "Connection settings saved successfully"
        Write-Log "Connection settings saved successfully"
    } else {
        $statusStripLabel.Text = "Failed to save connection settings"
        Write-Log "Failed to save connection settings" -Level "ERROR"
    }
}

function Load-ConnectionSettings {
    $loaded = Load-MigrationConfig
    if ($loaded) {
        Load-FormSettings
        $statusStripLabel.Text = "Connection settings loaded successfully"
        Write-Log "Connection settings loaded successfully"
    } else {
        $statusStripLabel.Text = "Failed to load connection settings"
        Write-Log "Failed to load connection settings" -Level "WARNING"
    }
}

#endregion

#region Script Management Functions

function Load-ScriptsList {
    try {
        # Clear the ListView
        $lvScripts.Items.Clear()
        
        # Sort scripts by order
        $sortedScripts = $script:Scripts | Sort-Object -Property Order
        
        # Add each script to the ListView
        foreach ($script in $sortedScripts) {
            $item = New-Object System.Windows.Forms.ListViewItem
            $item.Text = $script.Order.ToString()
            $item.SubItems.Add($script.Name)
            $item.SubItems.Add($script.Enabled.ToString())
            $lvScripts.Items.Add($item)
        }
        
        Write-Log "Loaded scripts list"
    }
    catch {
        Write-Log "Error loading scripts list: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error loading scripts list: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

function Add-ScriptToList {
    param (
        [string]$scriptPath = "",
        [string]$description = "",
        [bool]$enabled = $true
    )

    try {
        Write-Log "Starting Add-ScriptToList function"
        
        # If scriptPath is empty, show file dialog
        if ([string]::IsNullOrEmpty($scriptPath)) {
            Write-Log "Opening file dialog to select script"
            $openFileDialog = New-Object System.Windows.Forms.OpenFileDialog
            $openFileDialog.Filter = "PowerShell Scripts (*.ps1)|*.ps1|All files (*.*)|*.*"
            $openFileDialog.Title = "Select a PowerShell Script"
            
            if ($openFileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
                $scriptPath = $openFileDialog.FileName
                Write-Log "Selected script: $scriptPath"
            } else {
                Write-Log "File dialog canceled"
                return $false
            }
        }

        # Get script name from path
        $scriptName = [System.IO.Path]::GetFileName($scriptPath)
        Write-Log "Script name: $scriptName"

        # Initialize Scripts collection if it doesn't exist
        if ($null -eq $script:Scripts) {
            Write-Log "Initializing Scripts collection"
            $script:Scripts = @()
        }

        # Get the next order number
        $nextOrder = 1
        if ($script:Scripts.Count -gt 0) {
            $nextOrder = ($script:Scripts | Measure-Object -Property Order -Maximum).Maximum + 1
        }
        Write-Log "Next order number: $nextOrder"

        # Add to scripts collection first
        Write-Log "Adding script to collection"
        $script:Scripts += @{
            Order = $nextOrder
            Name = $scriptName
            Path = $scriptPath
            Description = $description
            Enabled = $enabled
            Parameters = @()
        }

        # Now try to add to ListView
        Write-Log "Creating ListViewItem"
        $item = New-Object System.Windows.Forms.ListViewItem
        
        Write-Log "Setting ListViewItem properties"
        $item.Text = $nextOrder.ToString()
        
        Write-Log "Adding first subitem"
        $item.SubItems.Add($scriptName)
        
        Write-Log "Adding second subitem"
        $item.SubItems.Add($enabled.ToString())

        Write-Log "Adding item to ListView"
        $lvScripts.Items.Add($item)

        Write-Log "Successfully added script: $scriptPath"
        return $true
    }
    catch {
        Write-Log "Error adding script: $($_.Exception.Message)" -Level "Error"
        Write-Log "Stack trace: $($_.ScriptStackTrace)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error adding script: $($_.Exception.Message)`n`nStack trace: $($_.ScriptStackTrace)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        return $false
    }
}

function Remove-ScriptFromList {
    try {
        # Check if a script is selected
        if ($lvScripts.SelectedItems.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("Please select a script to remove.", "No Script Selected", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
            return
        }
        
        # Get the selected script
        $selectedIndex = $lvScripts.SelectedIndices[0]
        $selectedOrder = [int]$lvScripts.Items[$selectedIndex].Text
        
        # Confirm deletion
        $scriptName = $lvScripts.Items[$selectedIndex].SubItems[1].Text
        $result = [System.Windows.Forms.MessageBox]::Show("Are you sure you want to remove the script '$scriptName'?", "Confirm Removal", [System.Windows.Forms.MessageBoxButtons]::YesNo, [System.Windows.Forms.MessageBoxIcon]::Question)
        
        if ($result -eq [System.Windows.Forms.DialogResult]::Yes) {
            # Remove from ListView
            $lvScripts.Items.RemoveAt($selectedIndex)
            
            # Remove from scripts collection
            $script:Scripts = $script:Scripts | Where-Object { $_.Order -ne $selectedOrder }
            
            # Clear the details
            Clear-ScriptDetails
            
            Write-Log "Removed script: $scriptName"
        }
    }
    catch {
        Write-Log "Error removing script: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error removing script: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

function Move-ScriptUp {
    try {
        # Check if a script is selected
        if ($lvScripts.SelectedItems.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("Please select a script to move.", "No Script Selected", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
            return
        }
        
        # Get the selected script
        $selectedIndex = $lvScripts.SelectedIndices[0]
        
        # Check if it's already at the top
        if ($selectedIndex -eq 0) {
            return
        }
        
        # Get the current and previous script
        $currentScript = $script:Scripts | Where-Object { $_.Order -eq [int]$lvScripts.Items[$selectedIndex].Text }
        $previousScript = $script:Scripts | Where-Object { $_.Order -eq [int]$lvScripts.Items[$selectedIndex - 1].Text }
        
        # Swap their order
        $tempOrder = $currentScript.Order
        $currentScript.Order = $previousScript.Order
        $previousScript.Order = $tempOrder
        
        # Update the ListView
        $lvScripts.Items[$selectedIndex].Text = $currentScript.Order.ToString()
        $lvScripts.Items[$selectedIndex - 1].Text = $previousScript.Order.ToString()
        
        # Refresh the ListView to reflect the new order
        Load-ScriptsList
        
        # Select the moved item
        $lvScripts.Items[$selectedIndex - 1].Selected = $true
        
        Write-Log "Moved script up: $($currentScript.Name)"
    }
    catch {
        Write-Log "Error moving script up: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error moving script up: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

function Move-ScriptDown {
    try {
        # Check if a script is selected
        if ($lvScripts.SelectedItems.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("Please select a script to move.", "No Script Selected", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
            return
        }
        
        # Get the selected script
        $selectedIndex = $lvScripts.SelectedIndices[0]
        
        # Check if it's already at the bottom
        if ($selectedIndex -eq ($lvScripts.Items.Count - 1)) {
            return
        }
        
        # Get the current and next script
        $currentScript = $script:Scripts | Where-Object { $_.Order -eq [int]$lvScripts.Items[$selectedIndex].Text }
        $nextScript = $script:Scripts | Where-Object { $_.Order -eq [int]$lvScripts.Items[$selectedIndex + 1].Text }
        
        # Swap their order
        $tempOrder = $currentScript.Order
        $currentScript.Order = $nextScript.Order
        $nextScript.Order = $tempOrder
        
        # Update the ListView
        $lvScripts.Items[$selectedIndex].Text = $currentScript.Order.ToString()
        $lvScripts.Items[$selectedIndex + 1].Text = $nextScript.Order.ToString()
        
        # Refresh the ListView to reflect the new order
        Load-ScriptsList
        
        # Select the moved item
        $lvScripts.Items[$selectedIndex + 1].Selected = $true
        
        Write-Log "Moved script down: $($currentScript.Name)"
    }
    catch {
        Write-Log "Error moving script down: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error moving script down: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

#endregion

#region Script Details Functions
function Load-ScriptDetails {
    Write-Log "Load-ScriptDetails: Starting" -Level "DEBUG"
    Write-Log "Load-ScriptDetails: btnDetectParams object is $($mainForm.btnDetectParams), Text: $($mainForm.btnDetectParams.Text), Enabled: $($mainForm.btnDetectParams.Enabled)" -Level "DEBUG" #CHECK STATE

    try {
        # Check if a script is selected
        if ($lvScripts.SelectedItems.Count -eq 0) {
            Write-Log "Load-ScriptDetails: No script selected" -Level "DEBUG"
            # Clear the details
            Clear-ScriptDetails
            $mainForm.btnDetectParams.Enabled = $false  # Disable it
            Write-Log "Load-ScriptDetails:  btnDetectParams ENABLING - FALSE (No Script Selected)" -Level "DEBUG" #CHECK ENABLING
            Write-Log "Load-ScriptDetails: btnDetectParams object is $($mainForm.btnDetectParams), Text: $($mainForm.btnDetectParams.Text), Enabled: $($mainForm.btnDetectParams.Enabled)" -Level "DEBUG" #CHECK STATE
            return
        }

        # Get the selected script
        Write-Log "Load-ScriptDetails: Getting selected script" -Level "DEBUG"
        $selectedIndex = $lvScripts.SelectedIndices[0]
        $selectedOrder = [int]$lvScripts.Items[$selectedIndex].Text
        Write-Log "Load-ScriptDetails:  selectedOrder is $($selectedOrder)" -Level "DEBUG" #CHECK selectedOrder
        $selectedScript = $script:Scripts | Where-Object { $_.Order -eq $selectedOrder }

        Write-Log "Load-ScriptDetails: selectedScript is $($selectedScript)" -Level "DEBUG"

        if ($null -eq $selectedScript) {
            Write-Log "Load-ScriptDetails: Selected script is null" -Level "DEBUG"
            Clear-ScriptDetails
            $mainForm.btnDetectParams.Enabled = $false  # Disable it
            Write-Log "Load-ScriptDetails:  btnDetectParams ENABLING - FALSE (selectedScript -eq null)" -Level "DEBUG" #CHECK ENABLING
            Write-Log "Load-ScriptDetails: btnDetectParams object is $($mainForm.btnDetectParams), Text: $($mainForm.btnDetectParams.Text), Enabled: $($mainForm.btnDetectParams.Enabled)" -Level "DEBUG" #CHECK STATE
            return
        }

        # Fill in the details
        $txtScriptPath.Text = $selectedScript.Path
        $txtScriptDescription.Text = $selectedScript.Description
        $chkScriptEnabled.Checked = $selectedScript.Enabled

        # Enable the details controls
        $grpScriptDetails.Enabled = $true
        $mainForm.btnDetectParams.Enabled = $true  # Enable it
        Write-Log "Load-ScriptDetails:  btnDetectParams ENABLING - TRUE (Valid Script)" -Level "DEBUG" #CHECK ENABLING
        Write-Log "Load-ScriptDetails: btnDetectParams object is $($mainForm.btnDetectParams), Text: $($mainForm.btnDetectParams.Text), Enabled: $($mainForm.btnDetectParams.Enabled)" -Level "DEBUG" #CHECK STATE

        Write-Log "Load-ScriptDetails: Loaded details for script: $($selectedScript.Name)"
    }
    catch {
        Write-Log "Error loading script details: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error loading script details: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

function Clear-ScriptDetails {
    try {
        $txtScriptPath.Text = ""
        $txtScriptDescription.Text = ""
        $chkScriptEnabled.Checked = $true
        $lvParameters.Items.Clear()
        $grpScriptDetails.Enabled = $true
    }
    catch {
        Write-Log "Error clearing script details: $($_.Exception.Message)" -Level "Error"
    }
}

function Save-ScriptDetails {
    try {
        if ($lvScripts.SelectedItems.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show(
                "Please select a script to save details for", 
                "No Script Selected", 
                [System.Windows.Forms.MessageBoxButtons]::OK, 
                [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }
        
        $selectedIndex = $lvScripts.SelectedIndices[0]
        $selectedOrder = [int]$lvScripts.Items[$selectedIndex].Text
        $selectedScript = $script:Scripts | Where-Object { $_.Order -eq $selectedOrder }
        
        Write-Log "Saving details for script: $($selectedScript.Name)" -Level "DEBUG"
        
        # Store current parameters before updating
        $currentParameters = $selectedScript.Parameters
        Write-Log "Current parameters count: $($currentParameters.Count)" -Level "DEBUG"
        
        # Update script details
        $selectedScript.Path = $txtScriptPath.Text
        $selectedScript.Description = $txtScriptDescription.Text
        $selectedScript.Enabled = $chkScriptEnabled.Checked
        
        # Preserve the parameters
        $selectedScript.Parameters = $currentParameters
        Write-Log "Preserved parameters count: $($selectedScript.Parameters.Count)" -Level "DEBUG"
        
        # Update ListView
        $lvScripts.Items[$selectedIndex].SubItems[1].Text = [System.IO.Path]::GetFileName($txtScriptPath.Text)
        $lvScripts.Items[$selectedIndex].SubItems[2].Text = $chkScriptEnabled.Checked.ToString()
        
        Write-Log "Saved details for script: $($selectedScript.Name)" -Level "INFO"
        $statusStripLabel.Text = "Saved script details"
        
        # Refresh the parameters ListView to show the preserved parameters
        $lvParameters.Items.Clear()
        foreach ($param in $currentParameters) {
            $item = New-Object System.Windows.Forms.ListViewItem($param.Name)
            
            # Get display value for the parameter
            $displayValue = Get-ParameterDisplayValue `
                -value $param.Value `
                -type $param.Type `
                -name $param.Name `
                -sourceServer $txtSourceServer.Text `
                -targetServer $txtTargetServer.Text `
                -sourceUsername $txtSourceUsername.Text `
                -targetUsername $txtTargetUsername.Text
            
            $item.SubItems.Add($displayValue)
            $item.SubItems.Add($param.Type)
            $lvParameters.Items.Add($item)
        }
        
        [System.Windows.Forms.MessageBox]::Show(
            "Script details saved successfully", 
            "Save Complete", 
            [System.Windows.Forms.MessageBoxButtons]::OK, 
            [System.Windows.Forms.MessageBoxIcon]::Information)
    }
    catch {
        Write-Log "Error saving script details: $($_.Exception.Message)" -Level "Error"
        Write-Log "Stack trace: $($_.ScriptStackTrace)" -Level "ERROR"
        [System.Windows.Forms.MessageBox]::Show(
            "Error saving script details: $($_.Exception.Message)", 
            "Error", 
            [System.Windows.Forms.MessageBoxButtons]::OK, 
            [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}


function Browse-ScriptFile {
    try {
        $openFileDialog = New-Object System.Windows.Forms.OpenFileDialog
        $openFileDialog.Filter = "PowerShell Scripts (*.ps1)|*.ps1|All files (*.*)|*.*"
        $openFileDialog.Title = "Select PowerShell Script"
        
        if ($script:config.ScriptsFolder -and (Test-Path $script:config.ScriptsFolder)) {
            $openFileDialog.InitialDirectory = $script:config.ScriptsFolder
        }
        
        if ($openFileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
            $txtScriptPath.Text = $openFileDialog.FileName
        }
    }
    catch {
        Write-Log "Error browsing for script file: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error browsing for script file: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

#endregion

#region Parameter Management Functions

function Detect-ScriptParameters {
    # Get the selected script
    $selectedIndex = $lvScripts.SelectedIndices[0]
    if ($selectedIndex -eq $null) {
        [System.Windows.Forms.MessageBox]::Show("Please select a script first.", "No Script Selected", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
        return
    }

    $scriptPath = $script:Scripts[$selectedIndex].Path
    $scriptName = [System.IO.Path]::GetFileName($scriptPath)  # Get the script name

    if (-not (Test-Path $scriptPath)) {
        [System.Windows.Forms.MessageBox]::Show("Script file not found: $($scriptName)", "File Not Found", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        return
    }

    try {
        # Clear existing parameters
        $lvParameters.Items.Clear()

        # Read the script content
        $scriptContent = Get-Content -Path $scriptPath -Raw -ErrorAction Stop

        Write-Log "Detecting parameters for script: $scriptName"

        # Parse the script using AST
        $ast = [System.Management.Automation.Language.Parser]::ParseInput($scriptContent, [ref]$null, [ref]$null)

        # Find the param block
        $paramBlock = $ast.ParamBlock
        if ($null -eq $paramBlock -or $null -eq $paramBlock.Parameters -or $paramBlock.Parameters.Count -eq 0) {
            Write-Log "No parameters found in script: $scriptName"
            [System.Windows.Forms.MessageBox]::Show("No parameters found in the script.", "No Parameters", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
            return
        }

        # Extract comment-based help for parameter descriptions
        $helpContent = $null
        if ($ast.GetHelpContent()) {
            $helpContent = $ast.GetHelpContent()
        }

        # Process each parameter
        $detectedParams = @()

        foreach ($param in $paramBlock.Parameters) {
            $paramName = $param.Name.VariablePath.UserPath
            Write-Log "Found parameter: $paramName"

            # Get parameter type
            $paramType = "String"  # Default type
            if ($param.StaticType) {
                $paramType = $param.StaticType.Name
            }

            # Get default value if any
            $defaultValue = ""
            if ($param.DefaultValue) {
                $defaultValue = $param.DefaultValue.Extent.Text
            }

            # Get description from help content if available
            $description = ""
            if ($helpContent -and $helpContent.Parameters -and $helpContent.Parameters.ContainsKey($paramName)) {
                $description = $helpContent.Parameters[$paramName]
            }

            # Set default values for common parameters
            if ($paramName -eq "vCenterConnection") {
                $defaultValue = "SourceConnection"
            }
            elseif ($paramName -eq "LogOutputLocation") {
                $defaultValue = $script:config.LogPath
            }
            elseif ($paramName -eq "ReportOutputLocation") {
                $defaultValue = $script:config.ReportsPath
            }

            # Create parameter object
            $paramObject = [PSCustomObject]@{
                Name        = $paramName
                Value       = $defaultValue
                Type        = $paramType
                Description = $description
            }

            $detectedParams += $paramObject

            # Add to ListView - with null checks
            $item = New-Object System.Windows.Forms.ListViewItem($paramName)
            if ($item -ne $null) {
                if ($defaultValue -ne $null) {
                    $item.SubItems.Add($defaultValue.ToString())
                }
                else {
                    $item.SubItems.Add("")
                }

                if ($paramType -ne $null) {
                    $item.SubItems.Add($paramType.ToString())
                }
                else {
                    $item.SubItems.Add("String")
                }

                $lvParameters.Items.Add($item)
            } else {
                Write-Log "Error: Failed to create ListView item for parameter $paramName" -Level "ERROR"
            }
        }

        # Update the script's parameters
        $script:Scripts[$selectedIndex].Parameters = $detectedParams

        # Add these for testing!
        $testParams = $script:Scripts[$selectedIndex].Parameters
        Write-Log "Count of parameters: $($testParams.Count)" -Level "DEBUG"
        foreach ($testParam in $testParams) {
            Write-Log "Parameter Name: $($testParam.Name) Value: $($testParam.Value) Type: $($testParam.Type)" -Level "DEBUG"
        }

        Write-Log "Detected $($detectedParams.Count) parameters for script: $scriptName"
        [System.Windows.Forms.MessageBox]::Show("Detected $($detectedParams.Count) parameters.", "Parameters Detected", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
    }
    catch {
        $errorMessage = "Error detecting script parameters: $($_.Exception.Message)"
        Write-Log $errorMessage -Level "ERROR"
        Write-Log "Stack Trace: $($_.ScriptStackTrace)" -Level "ERROR"
        [System.Windows.Forms.MessageBox]::Show($errorMessage, "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}


function Add-ScriptParameter {
    try {
        if ($lvScripts.SelectedItems.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("Please select a script first", "No Script Selected", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }
        
        # Create a parameter input form
        $paramForm = New-Object System.Windows.Forms.Form
        $paramForm.Text = "Add Parameter"
        $paramForm.Size = New-Object System.Drawing.Size(400, 250)
        $paramForm.StartPosition = "CenterParent"
        $paramForm.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::Sizable
        $paramForm.MaximizeBox = $false
        $paramForm.MinimizeBox = $false
        $paramForm.autosize = $true
        
        # Parameter name label
        $lblParamName = New-Object System.Windows.Forms.Label
        $lblParamName.Text = "Parameter Name:"
        $lblParamName.Location = New-Object System.Drawing.Point(20, 20)
        $lblParamName.Size = New-Object System.Drawing.Size(120, 20)
        $paramForm.Controls.Add($lblParamName)
        
        # Parameter name textbox
        $txtParamName = New-Object System.Windows.Forms.TextBox
        $txtParamName.Location = New-Object System.Drawing.Point(150, 20)
        $txtParamName.Size = New-Object System.Drawing.Size(200, 20)
        $paramForm.Controls.Add($txtParamName)
        
        # Parameter value label
        $lblParamValue = New-Object System.Windows.Forms.Label
        $lblParamValue.Text = "Parameter Value:"
        $lblParamValue.Location = New-Object System.Drawing.Point(20, 50)
        $lblParamValue.Size = New-Object System.Drawing.Size(120, 20)
        $paramForm.Controls.Add($lblParamValue)
        
        # Parameter value textbox
        $txtParamValue = New-Object System.Windows.Forms.TextBox
        $txtParamValue.Location = New-Object System.Drawing.Point(150, 50)
        $txtParamValue.Size = New-Object System.Drawing.Size(200, 20)
        $paramForm.Controls.Add($txtParamValue)
        
        # Parameter type label
        $lblParamType = New-Object System.Windows.Forms.Label
        $lblParamType.Text = "Parameter Type:"
        $lblParamType.Location = New-Object System.Drawing.Point(20, 80)
        $lblParamType.Size = New-Object System.Drawing.Size(120, 20)
        $paramForm.Controls.Add($lblParamType)
        
        # Parameter type combobox
        $cmbParamType = New-Object System.Windows.Forms.ComboBox
        $cmbParamType.Location = New-Object System.Drawing.Point(150, 80)
        $cmbParamType.Size = New-Object System.Drawing.Size(200, 20)
        $cmbParamType.DropDownStyle = [System.Windows.Forms.ComboBoxStyle]::DropDownList
        $paramTypes = @("String", "Int32", "Double", "Boolean", "DateTime", "PSCredential", "SecureString", "Object")
        foreach ($type in $paramTypes) {
            $cmbParamType.Items.Add($type)
        }
        $cmbParamType.SelectedIndex = 0
        $paramForm.Controls.Add($cmbParamType)
        
        # Use vCenter credentials checkbox
        $chkUseVCenterCreds = New-Object System.Windows.Forms.CheckBox
        $chkUseVCenterCreds.Text = "Use vCenter credentials"
        $chkUseVCenterCreds.Location = New-Object System.Drawing.Point(150, 110)
        $chkUseVCenterCreds.Size = New-Object System.Drawing.Size(200, 20)
        $paramForm.Controls.Add($chkUseVCenterCreds)
        
        # Source or Target radio buttons (only visible when using vCenter credentials)
        $pnlCredentialType = New-Object System.Windows.Forms.Panel
        $pnlCredentialType.Location = New-Object System.Drawing.Point(150, 130)
        $pnlCredentialType.Size = New-Object System.Drawing.Size(200, 30)
        $pnlCredentialType.Visible = $false
        $paramForm.Controls.Add($pnlCredentialType)
        
        $rbSource = New-Object System.Windows.Forms.RadioButton
        $rbSource.Text = "Source"
        $rbSource.Location = New-Object System.Drawing.Point(0, 0)
        $rbSource.Size = New-Object System.Drawing.Size(80, 20)
        $rbSource.Checked = $true
        $pnlCredentialType.Controls.Add($rbSource)
        
        $rbTarget = New-Object System.Windows.Forms.RadioButton
        $rbTarget.Text = "Target"
        $rbTarget.Location = New-Object System.Drawing.Point(90, 0)
        $rbTarget.Size = New-Object System.Drawing.Size(80, 20)
        $pnlCredentialType.Controls.Add($rbTarget)
        
        # Show/hide credential options based on checkbox
        $chkUseVCenterCreds.Add_CheckedChanged({
            $pnlCredentialType.Visible = $chkUseVCenterCreds.Checked
            if ($chkUseVCenterCreds.Checked) {
                $cmbParamType.SelectedItem = "PSCredential"
                $cmbParamType.Enabled = $false
                if ($rbSource.Checked) {
                    $txtParamValue.Text = "SourceCredential"
                } else {
                    $txtParamValue.Text = "TargetCredential"
                }
            } else {
                $cmbParamType.Enabled = $true
            }
        })
        
        $rbSource.Add_CheckedChanged({
            if ($rbSource.Checked) {
                $txtParamValue.Text = "SourceCredential"
            }
        })
        
        $rbTarget.Add_CheckedChanged({
            if ($rbTarget.Checked) {
                $txtParamValue.Text = "TargetCredential"
            }
        })
        
        # OK button
        $btnOK = New-Object System.Windows.Forms.Button
        $btnOK.Text = "OK"
        $btnOK.DialogResult = [System.Windows.Forms.DialogResult]::OK
        $btnOK.Location = New-Object System.Drawing.Point(150, 170)
        $btnOK.Size = New-Object System.Drawing.Size(75, 23)
        $paramForm.Controls.Add($btnOK)
        
        # Cancel button
        $btnCancel = New-Object System.Windows.Forms.Button
        $btnCancel.Text = "Cancel"
        $btnCancel.DialogResult = [System.Windows.Forms.DialogResult]::Cancel
        $btnCancel.Location = New-Object System.Drawing.Point(240, 170)
        $btnCancel.Size = New-Object System.Drawing.Size(75, 23)
        $paramForm.Controls.Add($btnCancel)
        
        $paramForm.AcceptButton = $btnOK
        $paramForm.CancelButton = $btnCancel
        
        # Show the form
        $result = $paramForm.ShowDialog()
        
        if ($result -eq [System.Windows.Forms.DialogResult]::OK) {
            $paramName = $txtParamName.Text.Trim()
            $paramValue = $txtParamValue.Text
            $paramType = $cmbParamType.SelectedItem
            
            if ([string]::IsNullOrEmpty($paramName)) {
                [System.Windows.Forms.MessageBox]::Show("Parameter name cannot be empty", "Invalid Input", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
                return
            }
            
            # Add to ListView
            $item = New-Object System.Windows.Forms.ListViewItem($paramName)
            $item.SubItems.Add($paramValue)
            $item.SubItems.Add($paramType)
            $lvParameters.Items.Add($item)
            
            # Add to script parameters
            $selectedIndex = $lvScripts.SelectedIndices[0]
            $selectedOrder = [int]$lvScripts.Items[$selectedIndex].Text
            $selectedScript = $script:Scripts | Where-Object { $_.Order -eq $selectedOrder }
            
            $selectedScript.Parameters += @{
                Name = $paramName
                Value = $paramValue
                Type = $paramType
            }
            
            Write-Log "Added parameter '$($paramName)' to script: $($selectedScript.Name)"
        }
    }
    catch {
        Write-Log "Error adding parameter: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error adding parameter: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

function Validate-OutputPath {
    param(
        [string]$Path,
        [switch]$CreateIfNotExists
    )

    try {
        # Check if path is null or empty
        if ([string]::IsNullOrWhiteSpace($Path)) {
            return $false
        }

        # Resolve full path (handles relative paths)
        $fullPath = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($Path)

        # Check if path is rooted (valid path structure)
        if (-not [System.IO.Path]::IsPathRooted($fullPath)) {
            Write-Log "Invalid path: $Path" -Level "ERROR"
            return $false
        }

        # If CreateIfNotExists is set, attempt to create directory
        if ($CreateIfNotExists) {
            if (-not (Test-Path $fullPath)) {
                try {
                    New-Item -Path $fullPath -ItemType Directory -Force | Out-Null
                    Write-Log "Created directory: $fullPath" -Level "INFO"
                } catch {
                    Write-Log "Could not create directory: $fullPath. Error: $_" -Level "ERROR"
                    return $false
                }
            }
        } else {
            # Just check if directory exists
            if (-not (Test-Path $fullPath -PathType Container)) {
                Write-Log "Path does not exist: $Path" -Level "WARNING"
                return $false
            }
        }

        return $true
    } catch {
        Write-Log "Error validating path: $_" -Level "ERROR"
        return $false
    }
}
function Show-EditParameterForm {
    param (
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$Parameter,

        [Parameter(Mandatory = $true)]
        [Hashtable]$ConnectionInfo,

        [Parameter(Mandatory = $true)]
        [string]$ScriptPath,

        [Parameter(Mandatory = $true)]
        [Hashtable]$Config
    )

    # Save the current directory
    $currentLocation = Get-Location
    
    try {
        # Get the form path from config or determine it
        $formPath = $Config.FormPath
        if ([string]::IsNullOrEmpty($formPath)) {
            $formPath = $PSScriptRoot # Use the directory of the current script
            Write-Log "Form path not found in config, using PSScriptRoot: $formPath" -Level "DEBUG"
        }

        Write-Log "Using form path: $formPath" -Level "DEBUG"

        # Verify the form files exist
        $designerPath = Join-Path -Path $formPath -ChildPath "EditParameterForm.designer.ps1"
        $formLogicPath = Join-Path -Path $formPath -ChildPath "EditParameterForm.ps1"

        if (-not (Test-Path $designerPath)) {
            throw "Designer file not found at: $designerPath"
        }
        if (-not (Test-Path $formLogicPath)) {
            throw "Form logic file not found at: $formLogicPath"
        }

        # Change to the form directory
        Set-Location -Path $formPath

        # Store config in script scope for Write-Log function
        $script:config = $Config

        # Source the form files
        Write-Log "Sourcing designer file: $designerPath" -Level "DEBUG"
        . $designerPath
        
        Write-Log "Sourcing form logic file: $formLogicPath" -Level "DEBUG"
        . $formLogicPath

        # Create and initialize the form
        $EditParameterForm = New-Object System.Windows.Forms.Form
        InitializeComponent

        # Store parameters in script scope for the form to access
        $script:Parameter = $Parameter
        $script:ConnectionInfo = $ConnectionInfo
        $script:ScriptPath = $ScriptPath

        Write-Log "Showing edit parameter form dialog" -Level "DEBUG"
        $result = $EditParameterForm.ShowDialog()

        if ($result -eq [System.Windows.Forms.DialogResult]::OK) {
            Write-Log "Dialog result OK, returning updated parameter" -Level "DEBUG"
            return $EditParameterForm.Tag
        }
        else {
            Write-Log "Dialog cancelled" -Level "DEBUG"
            return $null
        }
    }
    catch {
        Write-Log "Error in Show-EditParameterForm: $($_.Exception.Message)" -Level "ERROR"
        Write-Log "Stack trace: $($_.ScriptStackTrace)" -Level "ERROR"
        [System.Windows.Forms.MessageBox]::Show(
            "Error in Show-EditParameterForm: $($_.Exception.Message)", 
            "Error", 
            [System.Windows.Forms.MessageBoxButtons]::OK, 
            [System.Windows.Forms.MessageBoxIcon]::Error)
        return $null
    }
    finally {
        # Restore original location
        Set-Location -Path $currentLocation

        # Clean up script scope variables
        Remove-Variable -Name Parameter -Scope Script -ErrorAction SilentlyContinue
        Remove-Variable -Name ConnectionInfo -Scope Script -ErrorAction SilentlyContinue
        Remove-Variable -Name ScriptPath -Scope Script -ErrorAction SilentlyContinue

        # Dispose of form if it exists
        if ($EditParameterForm) {
            $EditParameterForm.Dispose()
        }
    }
}


function Remove-ScriptParameter {
    try {
        if ($lvScripts.SelectedItems.Count -eq 0 -or $lvParameters.SelectedItems.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("Please select a script and parameter to remove", "No Selection", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }
        
        $selectedScriptIndex = $lvScripts.SelectedIndices[0]
        $selectedOrder = [int]$lvScripts.Items[$selectedScriptIndex].Text
        $selectedScript = $script:Scripts | Where-Object { $_.Order -eq $selectedOrder }
        
        $selectedParamIndex = $lvParameters.SelectedIndices[0]
        $paramName = $lvParameters.SelectedItems[0].Text
        
        $result = [System.Windows.Forms.MessageBox]::Show("Are you sure you want to remove parameter '$($paramName)'?", "Confirm Removal", [System.Windows.Forms.MessageBoxButtons]::YesNo, [System.Windows.Forms.MessageBoxIcon]::Question)
        
        if ($result -eq [System.Windows.Forms.DialogResult]::Yes) {
            # Remove from ListView
            $lvParameters.Items.RemoveAt($selectedParamIndex)
            
            # Remove from script parameters
            $selectedScript.Parameters = $selectedScript.Parameters | Where-Object { $_.Name -ne $paramName }
            
            Write-Log "Removed parameter '$($paramName)' from script: $($selectedScript.Name)"
        }
    }
    catch {
        Write-Log "Error removing parameter: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error removing parameter: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

#endregion

#region Script Execution Functions

function Run-AllScripts {
    try {
        if ($script:Scripts.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("No scripts to run", "No Scripts", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }
        
        # Confirm execution
        $result = [System.Windows.Forms.MessageBox]::Show("Are you sure you want to run all enabled scripts?", "Confirm Execution", [System.Windows.Forms.MessageBoxButtons]::YesNo, [System.Windows.Forms.MessageBoxIcon]::Question)
        
        if ($result -eq [System.Windows.Forms.DialogResult]::Yes) {
            # Get enabled scripts
            $enabledScripts = $script:Scripts | Where-Object { $_.Enabled -eq $true } | Sort-Object -Property Order
            
            if ($enabledScripts.Count -eq 0) {
                [System.Windows.Forms.MessageBox]::Show("No enabled scripts to run", "No Enabled Scripts", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
                return
            }
            
            # Update UI
            Update-UIState -State "Running"
            $txtExecutionOutput.Clear()
            $progressOverall.Maximum = $enabledScripts.Count
            $progressOverall.Value = 0
            $progressCurrentScript.Value = 0
            
            Write-Log "Starting execution of $($enabledScripts.Count) scripts" -Level "INFO"
            
            # Start execution
            Start-ScriptExecution -Scripts $enabledScripts
        }
    }
    catch {
        Write-Log "Error running scripts: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error running scripts: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        Update-UIState -State "Error"
    }
}

function Run-SelectedScript {
    try {
        if ($lvScripts.SelectedItems.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("Please select a script to run", "No Script Selected", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }
        
        $selectedIndex = $lvScripts.SelectedIndices[0]
        $selectedOrder = [int]$lvScripts.Items[$selectedIndex].Text
        $script = $script:Scripts | Where-Object { $_.Order -eq $selectedOrder }
        
        if (-not $script.Enabled) {
            $result = [System.Windows.Forms.MessageBox]::Show("The selected script is disabled. Do you want to run it anyway?", "Script Disabled", [System.Windows.Forms.MessageBoxButtons]::YesNo, [System.Windows.Forms.MessageBoxIcon]::Question)
            
            if ($result -eq [System.Windows.Forms.DialogResult]::No) {
                return
            }
        }
        
        # Update UI
        Update-UIState -State "Running"
        $txtExecutionOutput.Clear()
        $progressOverall.Maximum = 1
        $progressOverall.Value = 0
        $progressCurrentScript.Value = 0
        
        Write-Log "Starting execution of script: $($script.Name)" -Level "INFO"
        
        # Start execution
        Start-ScriptExecution -Scripts @($script)
    }
    catch {
        Write-Log "Error running selected script: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error running selected script: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        Update-UIState -State "Error"
    }
}

function Start-ScriptExecution {
    param (
        [array]$Scripts
    )
    
    # Create a background runspace
    $script:runspace = [runspacefactory]::CreateRunspace()
    $script:runspace.ApartmentState = "STA"
    $script:runspace.ThreadOptions = "ReuseThread"
    $script:runspace.Open()
    
    # Create a synchronization hashtable to handle UI updates
    $syncHash = [hashtable]::Synchronized(@{})
    # Remove $host reference - not needed and can cause issues
    $syncHash.ProgressOverall = $progressOverall
    $syncHash.ProgressCurrentScript = $progressCurrentScript
    $syncHash.TxtExecutionOutput = $txtExecutionOutput
    $syncHash.StatusStripLabel = $statusStripLabel
    $syncHash.Form = $form
    $syncHash.BtnRunAll = $btnRunAll
    $syncHash.BtnRunSelected = $btnRunSelected
    $syncHash.BtnStopExecution = $btnStopExecution
    
    # Add variables to runspace
    $script:runspace.SessionStateProxy.SetVariable("syncHash", $syncHash)
    $script:runspace.SessionStateProxy.SetVariable("scripts", $Scripts)
    $script:runspace.SessionStateProxy.SetVariable("vCenterConfig", $script:vCenterConfig)
    $script:runspace.SessionStateProxy.SetVariable("executionSettings", $script:executionSettings)
    $script:runspace.SessionStateProxy.SetVariable("logPath", $script:config.LogPath)
    $script:runspace.SessionStateProxy.SetVariable("reportsPath", $script:config.ReportsPath)
    
    # Create PowerShell instance
    $script:powershell = [powershell]::Create()
    $script:powershell.Runspace = $script:runspace
    
    # Add script to execute
    $script:powershell.AddScript({
        # Function to safely update UI from background thread
        function Update-UI {
            param(
                [Parameter(Mandatory=$true)]
                [ScriptBlock]$Code
            )
            
            try {
                # Check if we need to use Invoke or can run directly
                if ($syncHash.Form.InvokeRequired) {
                    $syncHash.Form.Invoke([Action]{
                        Invoke-Command -ScriptBlock $Code
                    })
                } else {
                    Invoke-Command -ScriptBlock $Code
                }
            }
            catch {
                # If UI update fails, at least write to the log
                $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                $errorMsg = "[$timestamp] [ERROR] UI update failed: $($_.Exception.Message)"
                Add-Content -Path $logPath -Value $errorMsg
            }
        }
        
        # Function to write to log file and update UI
        function Write-ExecutionLog {
            param (
                [string]$Message,
                [string]$Level = "INFO"
            )
            
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            $logEntry = "[$timestamp] [$Level] $Message"
            
            # Write to log file
            try {
                Add-Content -Path $logPath -Value $logEntry -ErrorAction Stop
            }
            catch {
                # If log file write fails, continue execution
                $errorMsg = "Failed to write to log file: $($_.Exception.Message)"
                # Don't try to log this error to avoid recursion
            }
            
            # Update UI safely
            Update-UI {
                if ($null -ne $syncHash.TxtExecutionOutput) {
                    $syncHash.TxtExecutionOutput.AppendText("$logEntry`r`n")
                    $syncHash.TxtExecutionOutput.ScrollToCaret()
                }
                
                if ($null -ne $syncHash.StatusStripLabel) {
                    $syncHash.StatusStripLabel.Text = $Message
                }
            }
        }
        
        # Set global variable to track if script should stop
        $global:StopScript = $false
        
        # Function to create credentials
        function Get-VCenterCredential {
            param (
                [string]$Type
            )
            
            if ($vCenterConfig.UseCurrentCredentials) {
                return $null  # Will use current Windows credentials
            }
            
            if ($Type -eq "Source") {
                $username = $vCenterConfig.SourceUsername
                $password = $vCenterConfig.SourcePassword
            } else {
                $username = $vCenterConfig.TargetUsername
                $password = $vCenterConfig.TargetPassword
            }
            
            if ([string]::IsNullOrEmpty($username) -or [string]::IsNullOrEmpty($password)) {
                return $null
            }
            
            $secPassword = ConvertTo-SecureString $password -AsPlainText -Force
            return New-Object System.Management.Automation.PSCredential ($username, $secPassword)
        }
        
        # Function to write logs in a format the scripts can use
        function Write-Log {
            param (
                [string]$Message,
                [string]$Severity = "Info"
            )
            
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            $logEntry = "[$timestamp] [$Severity] $Message"
            
            try {
                Add-Content -Path $logPath -Value $logEntry -ErrorAction Stop
            }
            catch {
                # If log file write fails, continue execution
            }
            
            # Also write to the execution log
            Write-ExecutionLog $Message -Level $Severity
        }
        
        # Connect to vCenter servers
        $sourceServer = $null
        $targetServer = $null
        
        try {
            Write-ExecutionLog "Connecting to source vCenter: $($vCenterConfig.SourcevCenter)"
            
            # Check if PowerCLI is available
            if (-not (Get-Module -Name VMware.PowerCLI -ListAvailable)) {
                Write-ExecutionLog "VMware PowerCLI module is not installed. Cannot connect to vCenter." -Level "ERROR"
                
                # Update UI
                Update-UI {
                    $syncHash.BtnRunAll.Enabled = $true
                    $syncHash.BtnRunSelected.Enabled = $true
                    $syncHash.BtnStopExecution.Enabled = $false
                }
                
                return
            }
            
            # Import the module
            Write-ExecutionLog "Importing VMware.PowerCLI module..."
            #Import-Module VMware.PowerCLI -ErrorAction Stop
            
            # Set PowerCLI configuration to ignore certificate warnings
            Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -ErrorAction SilentlyContinue | Out-Null
            
            if ($vCenterConfig.UseCurrentCredentials) {
                $sourceServer = Connect-VIServer -Server $vCenterConfig.SourcevCenter -ErrorAction Stop
            } else {
                $sourceCredential = Get-VCenterCredential -Type "Source"
                if ($sourceCredential) {
                    $sourceServer = Connect-VIServer -Server $vCenterConfig.SourcevCenter -Credential $sourceCredential -ErrorAction Stop
                } else {
                    $sourceServer = Connect-VIServer -Server $vCenterConfig.SourcevCenter -ErrorAction Stop
                }
            }
            
            Write-ExecutionLog "Connecting to target vCenter: $($vCenterConfig.TargetvCenter)"
            
            if ($vCenterConfig.UseCurrentCredentials) {
                $targetServer = Connect-VIServer -Server $vCenterConfig.TargetvCenter -ErrorAction Stop
            } else {
                $targetCredential = Get-VCenterCredential -Type "Target"
                if ($targetCredential) {
                    $targetServer = Connect-VIServer -Server $vCenterConfig.TargetvCenter -Credential $targetCredential -ErrorAction Stop
                } else {
                    $targetServer = Connect-VIServer -Server $vCenterConfig.TargetvCenter -ErrorAction Stop
                }
            }
            
            Write-ExecutionLog "Successfully connected to both vCenter servers"
        }
        catch {
            Write-ExecutionLog "Failed to connect to vCenter servers: $($_)" -Level "ERROR"
            
            # Get detailed error information
            $errorMessage = $_.Exception.Message
            $errorType = $_.Exception.GetType().FullName
            $stackTrace = $_.ScriptStackTrace
            
            Write-ExecutionLog "Error Type: $errorType" -Level "ERROR"
            Write-ExecutionLog "Stack Trace: $stackTrace" -Level "ERROR"
            
            # Update UI
            Update-UI {
                $syncHash.BtnRunAll.Enabled = $true
                $syncHash.BtnRunSelected.Enabled = $true
                $syncHash.BtnStopExecution.Enabled = $false
            }
            
            return
        }
        
        # Execute scripts
        $totalScripts = $scripts.Count
        $currentScript = 0
        $sourceCredential = Get-VCenterCredential -Type "Source"
        $targetCredential = Get-VCenterCredential -Type "Target"
        
        foreach ($script in $scripts) {
            # Check if execution should stop
            if ($global:StopScript) {
                Write-ExecutionLog "Execution stopped by user" -Level "WARNING"
                break
            }
            
            $currentScript++
            
            # Update progress
            Update-UI {
                $syncHash.ProgressOverall.Value = [Math]::Min(100, [Math]::Round(($currentScript / $totalScripts) * 100))
                $syncHash.ProgressCurrentScript.Value = 0
            }
            
            Write-ExecutionLog "Executing script $($currentScript) of $($totalScripts): $($script.Name)"
            
            try {
                # Build parameter hashtable
                $parameters = @{}
                
                foreach ($param in $script.Parameters) {
                    $value = $param.Value
                    
                    # Handle special parameter values
                    if ($param.Type -eq "PSCredential") {
                        if ($value -eq "SourceCredential") {
                            $value = $sourceCredential
                        } elseif ($value -eq "TargetCredential") {
                            $value = $targetCredential
                        }
                    } elseif ($param.Type -eq "Int32" -or $param.Type -eq "Double") {
                        $value = [convert]::ChangeType($value, [type]$param.Type)
                    } elseif ($param.Type -eq "Boolean") {
                        $value = [System.Convert]::ToBoolean($value)
                    } elseif ($param.Type -eq "DateTime") {
                        $value = [datetime]$value
                    } elseif ($param.Name -eq "vCenter" -and $value -eq "SourcevCenter") {
                        $value = $vCenterConfig.SourcevCenter
                    } elseif ($param.Name -eq "vCenter" -and $value -eq "TargetvCenter") {
                        $value = $vCenterConfig.TargetvCenter
                    } elseif ($param.Name -eq "SourcevCenter" -or ($param.Name -eq "vCenter" -and $value -eq "SourcevCenter")) {
                        $value = $vCenterConfig.SourcevCenter
                    } elseif ($param.Name -eq "TargetvCenter") {
                        $value = $vCenterConfig.TargetvCenter
                    } elseif ($param.Name -eq "vCenterName" -and $value -eq "SourcevCenter") {
                        $value = "Source vCenter"
                    } elseif ($param.Name -eq "vCenterName" -and $value -eq "TargetvCenter") {
                        $value = "Target vCenter"
                    } elseif ($param.Name -eq "vCenterConnection" -and $value -eq "SourceConnection") {
                        $value = $sourceServer
                    } elseif ($param.Name -eq "vCenterConnection" -and $value -eq "TargetConnection") {
                        $value = $targetServer
                    } elseif ($param.Name -eq "LogOutputLocation") {
                        $value = $logPath
                    } elseif ($param.Name -eq "ReportOutputLocation") {
                        # Ensure the reports directory exists
                        if (-not (Test-Path $reportsPath)) {
                            New-Item -Path $reportsPath -ItemType Directory -Force | Out-Null
                        }
                        $value = $reportsPath
                    }
                    
                    $parameters[$param.Name] = $value
                }
                
                # Execute the script
                Write-ExecutionLog "Loading script content from: $($script.Path)"
                $scriptContent = Get-Content -Path $script.Path -Raw -ErrorAction Stop
                $scriptBlock = [scriptblock]::Create($scriptContent)
                
                Write-ExecutionLog "Starting script job with parameters: $($parameters.Keys -join ', ')"
                $job = Start-Job -ScriptBlock $scriptBlock -ArgumentList $parameters
                
                # Monitor job progress
                $timeout = $executionSettings.Timeout
                $elapsed = 0
                $interval = 1  # Check every second
                
                while ($job.State -eq "Running" -and $elapsed -lt $timeout -and -not $global:StopScript) {
                    Start-Sleep -Seconds $interval
                    $elapsed += $interval
                    
                    # Update progress
                    $progressPercent = [math]::Min(100, [math]::Round(($elapsed / $timeout) * 100))
                    Update-UI {
                        $syncHash.ProgressCurrentScript.Value = $progressPercent
                    }
                    
                    # Get job output
                    $output = Receive-Job -Job $job
                    if ($output) {
                        foreach ($line in $output) {
                            Write-ExecutionLog "  $($line)"
                        }
                    }
                }
                
                # Check job status
                if ($job.State -eq "Running") {
                    Stop-Job -Job $job
                    Write-ExecutionLog "Script execution timed out after $($timeout) seconds" -Level "WARNING"
                    
                    if ($executionSettings.StopOnError) {
                        Write-ExecutionLog "Stopping execution due to timeout" -Level "ERROR"
                        break
                    }
                } elseif ($global:StopScript) {
                    Stop-Job -Job $job
                    Write-ExecutionLog "Script execution stopped by user" -Level "WARNING"
                    break
                } else {
                    # Get final output
                    $output = Receive-Job -Job $job
                    if ($output) {
                        foreach ($line in $output) {
                            Write-ExecutionLog "  $($line)"
                        }
                    }
                    
                    if ($job.State -eq "Failed") {
                        # Get detailed error information
                        $errorDetails = $null
                        
                        # Try to get error details from the job
                        if ($job.ChildJobs[0].Error) {
                            $errorDetails = $job.ChildJobs[0].Error | Out-String
                        }
                        
                        # If we have error records, get more details
                        if ($job.ChildJobs[0].JobStateInfo.Reason) {
                            $errorDetails += "`nReason: " + ($job.ChildJobs[0].JobStateInfo.Reason | Out-String)
                        }
                        
                        # Get error record details if available
                        try {
                            $errorRecord = $job.ChildJobs[0].Error[0]
                            if ($errorRecord) {
                                $errorDetails += "`nException Type: $($errorRecord.Exception.GetType().FullName)"
                                $errorDetails += "`nException Message: $($errorRecord.Exception.Message)"
                                
                                if ($errorRecord.InvocationInfo) {
                                    $errorDetails += "`nPosition: $($errorRecord.InvocationInfo.PositionMessage)"
                                    $errorDetails += "`nLine Number: $($errorRecord.InvocationInfo.ScriptLineNumber)"
                                    $errorDetails += "`nOffset: $($errorRecord.InvocationInfo.OffsetInLine)"
                                    $errorDetails += "`nLine: $($errorRecord.InvocationInfo.Line)"
                                    $errorDetails += "`nScript Name: $($errorRecord.InvocationInfo.ScriptName)"
                                }
                                
                                # Get the inner exception details if available
                                if ($errorRecord.Exception.InnerException) {
                                    $errorDetails += "`nInner Exception: $($errorRecord.Exception.InnerException.Message)"
                                }
                                
                                # Get the stack trace
                                if ($errorRecord.Exception.StackTrace) {
                                    $errorDetails += "`nStack Trace: $($errorRecord.Exception.StackTrace)"
                                }
                            }
                        }
                        catch {
                            $errorDetails += "`nError extracting detailed error information: $($_)"
                        }
                        
                        # Log the detailed error
                        Write-ExecutionLog "Script execution failed with the following error:" -Level "ERROR"
                        foreach ($line in ($errorDetails -split "`n")) {
                            if (-not [string]::IsNullOrWhiteSpace($line)) {
                                Write-ExecutionLog "  $line" -Level "ERROR"
                            }
                        }
                        
                        if ($executionSettings.StopOnError) {
                            Write-ExecutionLog "Stopping execution due to error" -Level "ERROR"
                            break
                        }
                    } else {
                        Write-ExecutionLog "Script execution completed successfully"
                        
                        # Set progress to 100%
                        Update-UI {
                            $syncHash.ProgressCurrentScript.Value = 100
                        }
                    }
                }
                
                # Clean up job
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
            }
            catch {
                Write-ExecutionLog "Error executing script: $($_)" -Level "ERROR"
                Write-ExecutionLog "Error Type: $($_.Exception.GetType().FullName)" -Level "ERROR"
                Write-ExecutionLog "Stack Trace: $($_.ScriptStackTrace)" -Level "ERROR"
                
                if ($executionSettings.StopOnError) {
                    Write-ExecutionLog "Stopping execution due to error" -Level "ERROR"
                    break
                }
            }
        }
        
        # Disconnect from vCenter servers
        try {
            Write-ExecutionLog "Disconnecting from vCenter servers"
            Disconnect-VIServer -Server * -Confirm:$false -ErrorAction SilentlyContinue
        }
        catch {
            Write-ExecutionLog "Error disconnecting from vCenter servers: $($_)" -Level "WARNING"
        }
        
        # Update UI
        Update-UI {
            $syncHash.BtnRunAll.Enabled = $true
            $syncHash.BtnRunSelected.Enabled = $true
            $syncHash.BtnStopExecution.Enabled = $false
        }
        
        Write-ExecutionLog "Execution completed"
    })
    
    # Start asynchronous execution
    $script:handle = $script:powershell.BeginInvoke()
}

function Stop-ScriptExecution {
    try {
        if ($script:powershell -and $script:handle) {
            Write-Log "Stopping script execution" -Level "WARNING"
            
            # Stop the PowerShell instance
            $script:powershell.Stop()
            
            # Clean up
            $script:powershell.Dispose()
            $script:runspace.Dispose()
            
            # Update UI
            Update-UIState -State "Stopped"
            
            $statusStripLabel.Text = "Execution stopped by user"
            $txtExecutionOutput.AppendText("`r`n[$([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss'))] [WARNING] Execution stopped by user`r`n")
            $txtExecutionOutput.ScrollToCaret()
        }
    }
    catch {
        Write-Log "Error stopping script execution: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error stopping script execution: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

#endregion

#region Form Settings and Log Management Functions

function Load-FormSettings {
    try {
        Write-Log "Load-FormSettings: Starting" -Level "DEBUG"

        # Load connection settings
        $txtSourceServer.Text = $script:vCenterConfig.SourcevCenter
        $txtSourceUsername.Text = $script:vCenterConfig.SourceUsername
        $txtSourcePassword.Text = $script:vCenterConfig.SourcePassword
        $txtTargetServer.Text = $script:vCenterConfig.TargetvCenter
        $txtTargetUsername.Text = $script:vCenterConfig.TargetUsername
        $txtTargetPassword.Text = $script:vCenterConfig.TargetPassword
        
        # Set the checkbox value
        $chkUseCurrentCredentials.Checked = $script:vCenterConfig.UseCurrentCredentials
        
        # Manually update the UI based on checkbox state
        if ($chkUseCurrentCredentials.Checked) {
            $txtSourceUsername.Enabled = $false
            $txtSourcePassword.Enabled = $false
            $txtTargetUsername.Enabled = $false
            $txtTargetPassword.Enabled = $false
        } else {
            $txtSourceUsername.Enabled = $true
            $txtSourcePassword.Enabled = $true
            $txtTargetUsername.Enabled = $true
            $txtTargetPassword.Enabled = $true
        }
        
        # Load execution settings
        $chkStopOnError.Checked = $script:executionSettings.StopOnError
        $chkSkipConfirmation.Checked = $script:executionSettings.SkipConfirmation
        $numTimeout.Value = $script:executionSettings.Timeout
        $numMaxJobs.Value = $script:executionSettings.MaxConcurrentJobs

        # Load scripts list
        Write-Log "Loading scripts list" -Level "DEBUG"
        Write-Log "Scripts count: $($script:Scripts.Count)" -Level "DEBUG"
        
        $lvScripts.Items.Clear()
        
        # Sort scripts by order
        $sortedScripts = $script:Scripts | Sort-Object -Property Order
        
        foreach ($script in $sortedScripts) {
            Write-Log "Processing script: $($script.Name)" -Level "DEBUG"
            
            $item = New-Object System.Windows.Forms.ListViewItem
            $item.Text = $script.Order.ToString()
            $item.SubItems.Add([System.IO.Path]::GetFileName($script.Path))
            $item.SubItems.Add($script.Enabled.ToString())
            $lvScripts.Items.Add($item)
        }

        Write-Log "Scripts loaded to ListView. Count: $($lvScripts.Items.Count)" -Level "DEBUG"

        # Clear script details
        Clear-ScriptDetails

        Write-Log "Load-FormSettings: Completed" -Level "INFO"
    }
    catch {
        Write-Log "Error loading form settings: $($_.Exception.Message)" -Level "Error"
        Write-Log "Stack trace: $($_.ScriptStackTrace)" -Level "ERROR"
        [System.Windows.Forms.MessageBox]::Show(
            "Error loading form settings: $($_.Exception.Message)", 
            "Error", 
            [System.Windows.Forms.MessageBoxButtons]::OK, 
            [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}


function Refresh-Logs {
    try {
        # Clear the logs text box first
        if ($null -ne $mainForm.logTextBox) {
            $mainForm.logTextBox.Clear()
        } else {
            Write-Log "Error: logTextBox control is null" -Level "ERROR"
            return
        }
        
        # Check if log path is defined and file exists
        if ([string]::IsNullOrEmpty($script:config.LogPath)) {
            $mainForm.logTextBox.AppendText("Log path is not defined in configuration.`r`n")
            Write-Log "Error: Log path is not defined in configuration" -Level "ERROR"
            return
        }
        
        if (Test-Path $script:config.LogPath) {
            # Get the log content with error handling
            try {
                $logEntries = Get-Content -Path $script:config.LogPath -Tail 100 -ErrorAction Stop
                
                if ($null -eq $logEntries -or $logEntries.Count -eq 0) {
                    $mainForm.logTextBox.AppendText("Log file exists but is empty.`r`n")
                } else {
                    foreach ($entry in $logEntries) {
                        $mainForm.logTextBox.AppendText("$($entry)`r`n")
                    }
                }
                
                # Scroll to the end
                $mainForm.logTextBox.SelectionStart = $mainForm.logTextBox.Text.Length
                $mainForm.logTextBox.ScrollToCaret()
                
                $mainForm.statusStripLabel.Text = "Logs refreshed successfully"
            }
            catch {
                $mainForm.logTextBox.AppendText("Error reading log file: $($_.Exception.Message)`r`n")
                Write-Log "Error reading log file: $($_.Exception.Message)" -Level "ERROR"
            }
        } else {
            $mainForm.logTextBox.AppendText("Log file not found at $($script:config.LogPath)`r`n")
            Write-Log "Log file not found at $($script:config.LogPath)" -Level "WARNING"
        }
    }
    catch {
        # Handle any other errors
        $errorMessage = "Error refreshing logs: $($_.Exception.Message)"
        Write-Log $errorMessage -Level "ERROR"
        
        # Try to show error in UI if possible
        try {
            [System.Windows.Forms.MessageBox]::Show($errorMessage, "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        }
        catch {
            # If even showing the error fails, write to console
            Write-Host "Critical error in Refresh-Logs: $($errorMessage)" -ForegroundColor Red
        }
    }
}
function Clear-Logs {
    try {
        $result = [System.Windows.Forms.MessageBox]::Show("Are you sure you want to clear the log file?", "Confirm", [System.Windows.Forms.MessageBoxButtons]::YesNo, [System.Windows.Forms.MessageBoxIcon]::Question)
        if ($result -eq [System.Windows.Forms.DialogResult]::Yes) {
            Clear-Content -Path $script:config.LogPath -ErrorAction Stop
            $logTextBox.Clear()  # Use correct variable name
            $logTextBox.AppendText("Log file cleared at $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss'))`r`n")
            Write-Log "Log file cleared by user"
        }
    }
    catch {
        Write-Log "Error clearing logs: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error clearing logs: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

function Export-Logs {
    try {
        $saveFileDialog = New-Object System.Windows.Forms.SaveFileDialog
        $saveFileDialog.Filter = "Log files (*.log)|*.log|Text files (*.txt)|*.txt|All files (*.*)|*.*"
        $saveFileDialog.Title = "Export Logs"
        $saveFileDialog.FileName = "vCenterMigration_$([DateTime]::Now.ToString('yyyyMMdd_HHmmss')).log"
        
        if ($saveFileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
            Copy-Item -Path $script:config.LogPath -Destination $saveFileDialog.FileName -ErrorAction Stop
            $statusStripLabel.Text = "Logs exported to $($saveFileDialog.FileName)"
            Write-Log "Logs exported to $($saveFileDialog.FileName)"
        }
    }
    catch {
        Write-Log "Error exporting logs: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error exporting logs: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

function Save-AllSettings {
    try {
        # Save connection settings
        $script:vCenterConfig.SourcevCenter = $txtSourceServer.Text
        $script:vCenterConfig.SourceUsername = $txtSourceUsername.Text
        $script:vCenterConfig.SourcePassword = $txtSourcePassword.Text
        $script:vCenterConfig.TargetvCenter = $txtTargetServer.Text
        $script:vCenterConfig.TargetUsername = $txtTargetUsername.Text
        $script:vCenterConfig.TargetPassword = $txtTargetPassword.Text
        $script:vCenterConfig.UseCurrentCredentials = $chkUseCurrentCredentials.Checked
        
        # Save execution settings
        $script:executionSettings.StopOnError = $chkStopOnError.Checked
        $script:executionSettings.SkipConfirmation = $chkSkipConfirmation.Checked
        $script:executionSettings.Timeout = $numTimeout.Value
        $script:executionSettings.MaxConcurrentJobs = $numMaxJobs.Value
        
        # Save all settings
        $saved = Save-MigrationConfig
        if ($saved) {
            $statusStripLabel.Text = "All settings saved successfully"
            Write-Log "All settings saved successfully"
            [System.Windows.Forms.MessageBox]::Show("All settings saved successfully", "Save Complete", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        } else {
            $statusStripLabel.Text = "Failed to save settings"
            Write-Log "Failed to save settings" -Level "ERROR"
            [System.Windows.Forms.MessageBox]::Show("Failed to save settings", "Save Failed", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        }
    }
    catch {
        Write-Log "Error saving settings: $($_.Exception.Message)" -Level "Error"
        [System.Windows.Forms.MessageBox]::Show("Error saving settings: $($_.Exception.Message)", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
}

function Show-Help {
    $helpText = @"
vCenter Migration Workflow Manager Help

This tool helps you manage and execute PowerCLI scripts for vCenter migration.

Key Features:
- Connect to source and target vCenter servers
- Manage a collection of migration scripts
- Configure script parameters
- Execute scripts in sequence
- Monitor execution progress
- View and export logs

For more information, please contact your administrator.
"@
    
    [System.Windows.Forms.MessageBox]::Show($helpText, "Help", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
}

function Check-PowerCLI {
    try {
        Write-Log "Checking if VMware PowerCLI is available..."
        
        # Check if module is available without loading it
        $moduleAvailable = Get-Module -Name VMware.PowerCLI -ListAvailable
        
        if ($null -eq $moduleAvailable) {
            Write-Log "VMware PowerCLI module is not installed." -Level "Warning"
            $message = "VMware PowerCLI module is not installed. This tool requires PowerCLI for vCenter operations.`n`n"
            $message += "Please install PowerCLI using: Install-Module -Name VMware.PowerCLI -Scope CurrentUser"
            
            [System.Windows.Forms.MessageBox]::Show($message, "PowerCLI Not Found", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return $false
        }
        
        Write-Log "VMware PowerCLI module is installed."
        return $true
    }
    catch {
        Write-Log "Error checking PowerCLI: $($_.Exception.Message)" -Level "Error"
        return $false
    }
}

# Add to AI_Gen_Workflow_Wrapper.ps1



# Call this function in Initialize-Application
#endregion
